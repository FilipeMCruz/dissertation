\chapter{Design}
\label{chap:design}

This chapter goal is to describe the overall system design to the reader.
%First the reference architectures used for this project will be presented.
First the various system scopes will be introduced, followed by a section regarding the domain model.
After this the system's architectural design will be presented and major decisions/alternatives discussed. At last, a synopsis of this chapter can be read.

% \section{Reference Architecture}
% \label{sec:design:ref_architecture}

% TODO
% - 3 tier architecture
% - onion architecture pattern %  This pattern relies heavily on \gls{DIP} as it defends the isolation of business rules from infrastructure code, such as database access or rest endpoints.
% - reactive architecture
% - microservice architecture
% - data pipeline

\section{System Scopes}
\label{sec:design:system_scopes}

The system designed can be divided in three main scopes as disclosed in the Figure~\ref{fig:design:system_scopes:scopes}.

\begin{figure}[H]
    \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/scopes.latex}
   }
   \caption[System Scopes]{System Scopes}
   \label{fig:design:system_scopes:scopes}
\end{figure}

The \textbf{Configuration Scope} adheres to the configuration and visualization of internal processes/contexts. This processes, such as: (i) data decoders, (ii) data mappers (iii) device inventory, (iv) warning rule scenarios definition and (v) device ownership, are related to the \textbf{Data Flow Scope}. It is also possible to manage users' access and permissions in this scope.

The \textbf{Data Flow Scope} behaves according to what is defined in the \textbf{Configuration Scope} and acts as a pipeline where raw device data goes though various stages till it is sanitized and ready to be supplied to the \textbf{Services Scope}. The \textbf{Data Flow Scope} is where internal processes occur, such as: (i) data transformation, (ii) data enrichment, (iii) data validation, (iv) data ownership clarification and (v) alerts dispatching.

The \textbf{Services Scope} is comprised of services that present and act according to the sanitized data that was supplied to them. This services applicability range from (i) smart irrigation, (ii) fleet management, (iii) fire detention, (iv) physical security access monitoring, (v) air quality monitoring and anything else deemed interesting. The services currently developed are smart irrigation, fleet management and notification management, these will be addressed throughout this and the \nameref{chap:implementation} chapter.

\subsection{Configuration Scope}
\label{subsec:design:system_scopes:configuration_scope}

The \textbf{Configuration Scope} is responsible for managing the following contexts:

\begin{itemize}
   \item \textbf{Data Processor}: manages simple data mappers;
   \item \textbf{Data Decoder}: manages scripts to transform data;
   \item \textbf{Device Management}: manages device information such as name, metadata, static data and other notions;
   \item \textbf{Identity Management}: manages device ownership and users permissions;
   \item \textbf{Rule Management}: manages scripts that consume device data and produce alerts.
\end{itemize}

This contexts can be directly linked to the functional requirements described in the Section related to the~\ref{subsec:requirements:functional:manager} role.

Each context allows an authorized user to manage its resources, e.g. the data processor context manages the creation, deletion and renovation of data mappers.

This operations require various verification's, alter the system internal state and are therefore prolonged operations.

\subsection{Data Flow Scope}
\label{subsec:design:system_scopes:data_flow_scope}

The \textbf{Data Flow Scope} is responsible for processing incoming data according to what is defined in the \textbf{Configuration Scope}. Both scopes share the same contexts, apart from the data validation and data store contexts (only present in this scope).

The data validation context preforms basic data filtering based on static rules, e.g. battery percentage reported has to be in between 0 and 100.

The data store context persists data captured in a defined and static state.

This scope applies changes to the device data that flows though the system. This changes are stateless and don't change the overall state of the internal system state.

This scope was decoupled from the \textbf{Configuration Scope} even though they both work with the same contexts. The decision was taken based on the pretext that despite the similarities in context the operation/business processes of this two scopes were conflicting.

The \textbf{Configuration Scope} requires scarce but heavy computations that alter the internal system state while the \textbf{Data Flow Scope} requires plentiful but light computations that don't alter the internal system state as summarized in the Table~\ref{tab:design:system_scopes:data_flow_scope:comparison}.

\begin{table}[!ht]
   \centering
   \begin{tabular}{@{}lllll@{}}
   \toprule
   \textbf{Comparison of Operations} & \textbf{Configuration Scope} & \textbf{Data Flow Scope} \\ \midrule
       Alter internal system state & yes & no \\ \hline
       Alter sensor data & no & yes \\ \hline
       Required computation power/time & high & low \\ \hline
       Frequency of usage & low & high \\ \hline
   \end{tabular}
   \caption[Comparison of Operations in Data Flow and Configuration Scopes]{Comparison of Operations in Data Flow and Configuration Scopes}
   \label{tab:design:system_scopes:data_flow_scope:comparison}
\end{table}

Due to this discrepancy it's expected for each scope to have different requirements regarding horizontal scaling. With the addition of more devices to the platform, and subsequently higher ingress volume, \textbf{Data Flow Scope} will need to scale. Since the \textbf{Configuration Scope} is intended mostly for the manager of the platform, a small user pool, the need to scale is smaller.

\subsection{Service Scope}
\label{subsec:design:system_scopes:service_scope}

The \textbf{Service Scope} is responsible for presenting \gls{IoT} business cases to end users. This scope is comprised of services that consume and publish data to \textbf{Data Flow Scope}. Currently, as a \gls{MVP} the following business cases implemented are:

\begin{itemize}
   \item \textbf{Fleet Management}: basic service to monitor a fleet of cars regarding their location;
   \item \textbf{Smart Irrigation}: service to automate and monitor the irrigation of zones based on sensor readings;
   \item \textbf{Notification Management}: service to view and manage the delivery of triggered alerts.
\end{itemize}

Each service is bounded to what type of data receives and sends back to the \textbf{Data Flow Scope} as later detailed in the \nameref{subsec:implementation:description:services} section. The type of data each service handles is enforces by the concepts discussed in Sections~\ref{subsec:design:domain:taxonomy} and \ref{subsec:design:domain:shared_model}.

\subsection{Synopsis}
\label{subsec:design:system_scopes:synopsis}

This section introduces the system as three separated scopes each with different needs and responsibilities. Despite this they all have a common domain model. The Section~\ref{sec:design:domain} addresses this shared domain and each context peculiarity.

\section{Domain}
\label{sec:design:domain}

This system's domain model will be discussed here. The idea behind this section is to introduced core business concepts to the reader and explain how they map to the contexts present in the system. To represent this ideas the \gls{UML} notation is used.

This section is split into four pieces: (i) concepts, (ii) shared model, (iii) bounded contexts and (iv) synopsis.

\subsection{Taxonomy}
\label{subsec:design:domain:taxonomy}

In order for the reader to better understand how the system functions some concepts need to be better classified and explained:

\begin{itemize}
   \item \textbf{Device}: A device is a "Thing" that can collect data and submit it to \textbf{Sensae Console} via an external system though \textbf{Uplink}s. A device can, optionally, receive \textbf{Downlink}s;
   \item \textbf{Controller}: A controller is a \textbf{Device} that controls and aggregates data from various \textbf{Device}s;
   \item \textbf{Records/Metadata}: Records, or Metadata are labels associated to a \textbf{Device} that help an organization to classify and add some context to the owned \textbf{Device}s;
   \item \textbf{Downlink}: A downlink is a term commonly used in radio communications to denote the transmission from the network to the end user. In this case the network is the \textbf{Sensae Console} and the end user is a \textbf{Device};
   \item \textbf{Uplink}: An uplink is the opposite of a \textbf{Downlink}, it's the transmission from a \textbf{Device} to the \textbf{Sensae Console};
   \item \textbf{Data Unit}: A device data or measure is the collected data that is submitted via an \textbf{Uplink} to the \textbf{Sensae Console}. This data should be, at least, enriched with an unique identifier of the \textbf{Uplink} and \textbf{Device} that sent it;
   \item \textbf{Device Command}: A device command is an abstraction on top of a \textbf{Downlink} intended to order a \textbf{Device} to execute a specific action. As an example, one could send a command to open or close a valve that is incorporated into a \textbf{Controller};
   \item \textbf{Decoder}: A decoder is a function that translates a \textbf{Data Unit} into something that \textbf{Sensae Console} understands;
   \item \textbf{Domain}: A domain represents a department in a organization. An organization is composed of several domains structured in a tree like format;
   \item \textbf{Tenant}: A tenant is a user that belongs to one or more \textbf{Domain}s and represents any of the roles discussed in Section~\ref{sec:requirements:functional};
   \item \textbf{Alert}: A report about a detected condition based on the gather \textbf{Data Unit};
   \item \textbf{Topic}: A Topic is a subcategory of the type of contents that are traded between the various containers in the system.
\end{itemize}

Currently the \textbf{Topic}s that flow in the system are:

\begin{itemize}
   \item \textbf{Data}: This topic references the \textbf{Data Unit} concept and is intended to be consumed by the \textbf{Service Scope};
   \item \textbf{Command}: This topic references the \textbf{Device Command} concept and is intended to be used mainly by the \textbf{Service Scope};
   \item \textbf{Alert}: This topic references the \textbf{Alert} concept and is intended to be consumed mainly by the \textbf{Service Scope};
   \item \textbf{Internal}: This topic references the internal state maintained in the \textbf{Configuration Scope} and \textbf{Data Flow Scope}.
\end{itemize}

This concepts are referenced across the document.

\subsection{Shared Model}
\label{subsec:design:domain:shared_model}

The shared model is comprised of concepts that transverse the entire \textbf{Sensae Console} business model. Therefore, it is built as a separated project, \textit{iot-core}, that can be imported in each micro service. It can be seen as a bounded context that focus on defining the protocol of exchange of information between the various entities of the system.

The intent behind this Shared Model is to alleviate one of the issues related to distributed systems - heterogeneity in data formats (\cite{nadiminti2006distributed}) - and to provide a simple \gls{SDK} for third-parties to develop new services that interact with \textbf{Sensae Console}. It can be seen as an explicit schema. According to \cite{explicitsharedmodel}, ``any implementation of event-based communication between a producer and consumer that lacks an explicit predefined schema will inevitably end up relying on an implicit schema. Implicit data contracts are brittle and susceptible to uncontrolled change, which can cause much undue hardship to downstream consumers.''

According to \cite{integration}, ``while we have historically drawn up our project plans and costs around the boxes — the digital products we are introducing — the lines are the hidden and often primary driver of organizational tech debt. They are the reason that things just take longer now than they used to.'' The \textit{'lines'} in this solution are a first class citizen and, instead of just linking the system together, they act as the pillars that shape the entire ecosystem.

It is comprised of three big components: (i) data model, (ii) message envelop model, and (iii) routing model.

\subsubsection*{Data Model}
\label{subsubsec:design:domain:shared_model:data}

The data model represents the \textbf{Data Unit} that \textbf{Sensae Console} is currently capable of understanding. The following diagram, Figure~\ref{fig:design:domain:shared_model:data:diagram}, introduces a high level specification of it.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/shared-model.latex}
  }
  \caption[Shared Model]{Shared Model}
  \label{fig:design:domain:shared_model:data:diagram}
\end{figure}

As a brief description:

\begin{itemize}
   \item \textbf{Data Unit} is represented in the diagram as \textit{Data} and is the entry point to the shared model;
   \item The \textit{reportedAt} field represents the unix timestamp when the \textbf{Data Unit} was captured, in milliseconds;
   \item The \textit{Device} concept represents the \textbf{Device} that sent the \textit{Data}, and therefore the \textit{Data};
   \item The \textit{Record} concept represents an entry of \textbf{Records/Metadata};
   \item The \textit{Domain} concept references the \textbf{Domain} that owns the \textit{Device};
   \item The \textit{SubDeviceMeasures} concept introduces an approach to handle \textbf{Controller}s by mapping readings captured by a sub device to a \textit{reference} that can later be resolved;
   \item The \textit{SubDeviceCommands} concept introduces an approach to handle \textbf{Controller}s by mapping commands tailored for a sub device to a \textit{reference} that can later be resolved;
   \item The \textit{Measures} concept contains various common data types related to \gls{IoT}.
\end{itemize}

As explained, \textit{Measures} contains various data types. Currently the supported types are presented in the Table~\ref{tab:design:domain:shared_model:data:data_types}.

\begin{landscape}
   \begin{longtable}{cllll}
   \cline{1-4}
   \multicolumn{2}{l}{\textbf{Data Type}}                                     & \multirow{2}{*}{\textbf{Description}}                  & \multirow{2}{*}{\textbf{Unit}} &  \\
   \textit{Property}                     & \textit{Sub Property}              &                                                        &                                &  \\ \cline{1-4}
   \endfirsthead
   %
   \multicolumn{5}{c}%
   {{\bfseries Table \thetable\ continued from previous page}} \\
   \cline{1-4}
   \multicolumn{2}{l}{\textbf{Data Type}}                                     & \multirow{2}{*}{\textbf{Description}}                  & \multirow{2}{*}{\textbf{Unit}} &  \\
   \textit{Property}                     & \textit{Sub Property}              &                                                        &                                &  \\ \cline{1-4}
   \endhead
   %
   \\
   \cline{1-4}
   \\
   \endfoot
   %
   \endlastfoot
   %
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Motion}}                                        & \multicolumn{2}{l}{Status related to the motion of a device}                            &  \\
   \textit{motion}                       & \textit{value}                     & Value can be "ACTIVE", "INACTIVE" or "UNKNOWN"         & n.a.                           &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Velocity}}                                      & \multicolumn{2}{l}{How fast a device is moving}                                         &  \\
   \textit{velocity}                     & \textit{kilometerPerHour}          & Value measured in                                      & km/h                           &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Temperature}}                                   & \multicolumn{2}{l}{Temperature measured by a device}                                    &  \\
   \textit{temperature}                  & \textit{celsius}                   & Value measured in                                      & celsius                        &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{AQI}}                                           & \multicolumn{2}{l}{Air Quality Index according to the U.S. AQI}                         &  \\
   \textit{aqi}                          & \textit{value}                     & Value measured in                                      & AQI                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Air Humidity}}                                  & \multicolumn{2}{l}{Concentration of water vapour present in the air}                    &  \\
   \multirow{2}{*}{\textit{airHumidity}} & \textit{gramsPerCubicMeter}        & Value measured in                                      & g/m3                           &  \\
                                         & \textit{relativePercentage}        & Value measured in                                      & \%                             &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Air Pressure}}                                  & \multicolumn{2}{l}{Pressure within the atmosphere of Earth}                             &  \\
   \textit{airPressure}                  & \textit{hectoPascal}               & Value measured in                                      & hPa                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Distance}}                                      & \multicolumn{2}{l}{Distance measured from the device to a surface}                      &  \\
   \multirow{3}{*}{\textit{distance}}    & \textit{millimeters}               & Value measured in                                      & mm                             &  \\
                                         & \textit{maxMillimeters}            & Maximum distance the sensor can be to a given surface  & mm                             &  \\
                                         & \textit{minMillimeters}            & Minimum distance the sensor can be to a given surface  & mm                             &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Soil Moisture}}                                 & \multicolumn{2}{l}{Amount of water, including water vapor, in an unsaturated soil}      &  \\
   \textit{soilMoisture}                  & \textit{relativePercentage}        & Value measured in                                      & \%                             &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Water Pressure}}                                & \multicolumn{2}{l}{Water Pressure measured in pipes by a device}                        &  \\
   \textit{waterPressure}                & \textit{bar}                       & Value measured in                                      & bar                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Battery}}                                       & \multicolumn{2}{l}{Battery of the device}                                               &  \\
   \multirow{4}{*}{\textit{battery}}     & \textit{volts}                     & Value measured in                                      & volts                          &  \\
                                         & \textit{percentage}                & Value measured in                                      & \%                             &  \\
                                         & \textit{maxVolts}                  & Minimum volts the battery needs for the device to work & volts                          &  \\
                                         & \textit{minVolts}                  & Maximum volts the battery can hold                     & volts                          &  \\ [0.4em] \cline{1-4}
   %\pagebreak
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Illuminance}}                                   & \multicolumn{2}{l}{Illuminance level - luminous flux per unit area}                     &  \\
   \textit{illuminance}                  & \textit{lux}                       & Value measured in                                      & lux                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Trigger}}                                       & \multicolumn{2}{l}{Type related to something with an on / off or open / close state}    &  \\
   \textit{trigger}                      & \textit{value}                     & Value true or false                                    & boolean                        &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{CO2}}                                           & \multicolumn{2}{l}{Atmospheric Carbon Dioxide concentration}                            &  \\
   \textit{co2}                          & \textit{ppm}                       & Value measured in                                      & ppm                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{CO}}                                            & \multicolumn{2}{l}{Atmospheric Carbon Oxide concentration}                              &  \\
   \textit{co}                           & \textit{ppm}                       & Value measured in                                      & ppm                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{VOC}}                                           & \multicolumn{2}{l}{Volatile Organic Compounds concentration measured by a device}       &  \\
   \textit{voc}                          & \textit{ppm}                       & Value measured in                                      & ppm                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{NH3}}                                           & \multicolumn{2}{l}{Atmospheric Ammonia concentration}                                   &  \\
   \textit{nh3}                          & \textit{ppm}                       & Value measured in                                      & ppm                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{O3}}                                            & \multicolumn{2}{l}{Atmospheric Ozone concentration measured by a device}                &  \\
   \textit{o3}                           & \textit{ppm}                       & Value measured in                                      & ppm                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{NO2}}                                           & \multicolumn{2}{l}{Atmospheric Nitrogen dioxide concentration}                          &  \\
   \textit{no2}                          & \textit{ppm}                       & Value measured in                                      & ppm                            &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{PM2.5}}                                         & \multicolumn{2}{l}{Particulate Matter in the air (size up to 2.5 micrometers)}          &  \\
   \textit{pm2\_5}                       & \textit{microGramsPerCubicMeter}   & Value measured in                                      & $\mu$g/m3                      &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{PM10}}                                          & \multicolumn{2}{l}{Particulate Matter in the air (size up to 10 micrometers)}           &  \\
   \textit{pm10}                         & \textit{microGramsPerCubicMeter}   & Value measured in                                      & $\mu$g/m3                      &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{pH}}                                            & \multicolumn{2}{l}{Scale used to specify how acidic or basic a water-based solution is} &  \\
   \textit{ph}                           & \textit{value}                     & Value between 0 and 14 measured in                     & pH                             &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Occupation}}                                    & Occupation percentage measured inside a vessel         &                                &  \\
   \textit{occupation}                   & \textit{percentage}                & Value measured in                                      & \%                             &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{Soil Conductivity}}                             & \multicolumn{2}{l}{Substances ability to conduct an electrical current in the soil}     &  \\
   \textit{soilConductivity}             & \textit{microSiemensPerCentimeter} & Value measured in                                      & $\mu$S/cm                      &  \\ [0.4em] \cline{1-4}
   \\[-0.85em]
   \multicolumn{2}{l}{\textbf{GPS}}                                           & \multicolumn{2}{l}{Point reference in the Geographic Coordinate System}                 &  \\
   \multirow{3}{*}{\textit{gps}}         & \textit{latitude}                  & Value between -90 and 90 measured in                   & degrees                        &  \\
                                         & \textit{longitude}                 & Value between -180 and 180 measured in                 & degrees                        &  \\
                                         & \textit{altitude}                  & Value determined according to the mean sea level       & meters                         &  \\ [0.4em] \cline{1-4}
   \caption{Measure Data Types}
   \label{tab:design:domain:shared_model:data:data_types}\\
   \end{longtable}
\end{landscape}

The current shared model schema can be found in Appendix~\ref{AppendixA}.

\subsubsection*{Message Envelop Model}
\label{subsubsec:design:domain:shared_model:message}

The message envelop model refers to how, coupled with the routing model in Section~\ref{subsubsec:design:domain:shared_model:routing}, information can easily transverse the system.

The diagram present in Figure~\ref{fig:design:domain:shared_model:messsage:diagram} details this model.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/message-envelop-model.latex}
  }
  \caption[Message Envelop Model]{Message Envelop Model}
  \label{fig:design:domain:shared_model:messsage:diagram}
\end{figure}

As a brief description:

\begin{itemize}
   \item A \textit{MessageSupplied} is created in a container and supplied to start the flow of information in the system;
   \item A \textit{MessageConsumed} is consumed by a container and can then be transformed into a \textit{MessageSupplied} if needed;
   \item \textit{Information} represents the content of the message;
   \item \textit{RoutingKeys} represents the model referenced in Section~\ref{subsubsec:design:domain:shared_model:routing};
\end{itemize}

This concept is mainly used to ensure that information flowing in the system is not reprocessed, by verifying the unique id - \textit{oid}, and is drooped if it enters a routing loop by verifying that the \textit{hops} have not reached a maximum value.  

\subsubsection*{Routing Model}
\label{subsubsec:design:domain:shared_model:routing}

The routing model refers to how information can be routed through the system based on various parameters. The initial and current idea is based on the \textit{pub/sub} pattern, as discussed by \cite{urquhart2021flow}. Containers subscribe to information in a \textbf{Topic} with specific \textit{RoutingKey}s and publish information with \textit{RoutingKey}s.

The diagram present in Figure~\ref{fig:design:domain:shared_model:routing:diagram} details this model.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/routing-model.latex}
  }
  \caption[Routing Model]{Routing Model}
  \label{fig:design:domain:shared_model:routing:diagram}
\end{figure}

As a brief description:

\begin{itemize}
   \item \textit{RoutingKeys} is the concept referenced in Figure~\ref{fig:design:domain:shared_model:messsage:diagram} and represents a collection of different \textit{RoutingKeyOption}s;
   \item There are currently 4 types of \textit{RoutingKeys}, one for each \textbf{Topic};
   \item To ensure that the various containers in \textbf{Sensae Console} understand each other a \textit{ProtocolVersionOptions} is provided. This concept follows the Semantic Versioning Specification 2.0 (\cite{semver}) an is constructed according to the version of \textit{iot-core} imported by the container;
   \item There are multiple \textit{RoutingKey} types not displayed in the diagram for brevity.
   \item The \textit{RoutingKeysBuilder} implements the \textit{Builder} pattern and its single responsibility is to validate and create \textit{RoutingKeys};
   \item A \textit{RoutingKeyOption} can have the value \textit{any}, if the \textit{RoutingKeysBuilderOptions} has the value \textit{CONSUMER}. This provides a 'relaxed' mode, for containers that consume/subscribe to messages and a 'strict' mode, where each \textit{RoutingKey} must be specified, for containers that supply/publish messages. 
\end{itemize}

In the Table~\ref{tab:design:domain:shared_model:routing} all currently used \textit{RoutingKey} are presented.

\begin{landscape}
   \begin{longtable}{cll}
   \cline{1-2}
   \multicolumn{1}{l}{\textbf{Topic}}      & \multirow{2}{*}{\textbf{Description}}                                                                     &  \\
   \textit{Routing Key}                    &                                                                                                           &  \\ \cline{1-2}
   \endfirsthead
   %
   \multicolumn{3}{c}%
   {{\bfseries Table \thetable\ continued from previous page}} \\
   \cline{1-2}
   \multicolumn{1}{l}{\textbf{Topic}}      & \multirow{2}{*}{\textbf{Description}}                                                                     &  \\
   \textit{Routing Key}                    &                                                                                                           &  \\ \cline{1-2}
   \endhead
   %
   \cline{1-2}
   \endfoot
   %
   \endlastfoot
   %
   \multicolumn{1}{l}{\textbf{Common}}     & Routing Keys that belong to every Topic                                                                   &  \\
   \textit{Protocol Version Options}       & Version of the used \textit{iot-core} package                                                             &  \\
   \textit{Container Type Options}         & Type of the Container that published the message                                                          &  \\
   \textit{Ownership Options}              & Does the message contains the \textbf{Domain}s that own it\footnotemark[1]                                &  \\
   \textit{Topic Type Options}             & Topic used to publish the message                                                                         &  \\ \cline{1-2}
   \multicolumn{1}{l}{\textbf{Internal}}   & Routing Keys that belong to the Internal Topic                                                            &  \\
   \textit{Operation Type Options}         & Intent of the message, e.g. unknown context found                                                         &  \\
   \textit{Context Type Options}           & Type of content in the message, e.g. device information                                                   &  \\ \cline{1-2}
   \multicolumn{1}{l}{\textbf{Data}}       & Routing Keys that belong to the Data Topic                                                                &  \\
   \textit{Info Type Options}              & How data is shaped: (i) ENCODED, (ii) DECODED and (iii) PROCESSED                                         &  \\
   \textit{Device Type Options}            & Type of device, e.g. LGT-92 or EM300-TH                                                                   &  \\
   \textit{Channel Options}                & Name of channel where data flows, e.g. \textit{smartIrrigation} or \textit{default}                       &  \\
   \textit{Data Legitimacy Options}        & Is the data legitimate: (i) UNKNOWN, (ii) CORRECT, (iii) INCORRECT and (iv) UNDETERMINED      &  \\
   \textit{Records Options}                & Does the data contains \textbf{Records/Metadata}\footnotemark[1]                                          &  \\
   \textit{Air Humidity Data Options}      & Does the data contains information about Air Humidity\footnotemark[1]\footnotemark[2]                     &  \\
   \textit{Air Pressure Data Options}      & Does the data contains information about Air Pressure\footnotemark[1]\footnotemark[2]                     &  \\
   \textit{Air Quality Data Options}       & Does the data contains information about Air Quality\footnotemark[1]\footnotemark[2]                      &  \\
   \textit{Battery Data Options}           & Does the data contains information about the device Battery\footnotemark[1]\footnotemark[2]               &  \\
   \textit{CO2 Data Options}               & Does the data contains information about CO2 levels\footnotemark[1]\footnotemark[2]                       &  \\
   \textit{CO Data Options}                & Does the data contains information about CO levels\footnotemark[1]\footnotemark[2]                        &  \\
   \textit{Distance Data Options}          & Does the data contains information about distances to a surface\footnotemark[1]\footnotemark[2]           &  \\
   \textit{GPS Data Options}               & Does the data contains information about the device GPS coordinates\footnotemark[1]\footnotemark[2]       &  \\
   \textit{Illuminance Data Options}       & Does the data contains information about illuminance in the environment\footnotemark[1]\footnotemark[2]   &  \\
   \textit{Motion Data Options}            & Does the data contains information about the device motion\footnotemark[1]\footnotemark[2]                &  \\
   \textit{NH3 Data Options}               & Does the data contains information about NH3 levels\footnotemark[1]\footnotemark[2]                       &  \\
   \textit{NO2 Data Options}               & Does the data contains information about NO2 levels\footnotemark[1]\footnotemark[2]                       &  \\
   \textit{O3 Data Options}                & Does the data contains information about O3 levels\footnotemark[1]\footnotemark[2]                        &  \\
   \textit{Occupation Data Options}        & Does the data contains information about occupation levels\footnotemark[1]\footnotemark[2]                &  \\
   \textit{pH Data Options}                & Does the data contains information about ph level\footnotemark[1]\footnotemark[2]                         &  \\
   \textit{PM2.5 Data Options}             & Does the data contains information about pm 2.5 concentration\footnotemark[1]\footnotemark[2]             &  \\
   \textit{PM10 Data Options}              & Does the data contains information about pm 10 concentration\footnotemark[1]\footnotemark[2]              &  \\
   \textit{Soil Conductivity Data Options} & Does the data contains information about the soil conductivity\footnotemark[1]\footnotemark[2]            &  \\
   \textit{Soil Moisture Data Options}     & Does the data contains information about the soil moisture\footnotemark[1]\footnotemark[2]                &  \\
   \textit{Temperature Data Options}       & Does the data contains information about the temperature\footnotemark[1]\footnotemark[2]                  &  \\
   \textit{Trigger Data Options}           & Does the data contains information about something that works as a switch\footnotemark[1]\footnotemark[2] &  \\
   \textit{Velocity Data Options}          & Does the data contains information about the device velocity\footnotemark[1]\footnotemark[2]              &  \\
   \textit{VOC Data Options}               & Does the data contains information about VOC concentration\footnotemark[1]\footnotemark[2]                &  \\
   \textit{Water Pressure Data Options}    & Does the data contains information about water pressure\footnotemark[1]\footnotemark[2]                   &  \\ \cline{1-2}
   \multicolumn{1}{l}{\textbf{Command}}    & Routing Keys that belong to the Command Topic                                                             &  \\
   \textit{Command Type Options}           & Type of command, e.g. Open Valve                                                                          &  \\ \cline{1-2}
   \multicolumn{1}{l}{\textbf{Alert}}      & Routing Keys that belong to the Alert Topic                                                               &  \\
   \textit{Alert Category Options}         & Category of the alert published, e.g. Fire Detention                                                      &  \\
   \textit{Alert Subcategory Options}      & Category of the alert published, e.g. Humidity With High Rate Of Change                                   &  \\
   \textit{Alert Severity Options}         & Severity of the alert published, from \textit{Information} level to \textit{Critical} level               &  \\ \cline{1-2}
   \caption{Routing Types}
   \label{tab:design:domain:shared_model:routing}\\
   \end{longtable}
   \footnotetext[1]{has three possible values: (i) UNDETERMINED, (ii) WITH, (iii) WITHOUT}
   \footnotetext[2]{related to the explored Data Types}
\end{landscape}

The routing key \textit{OperationType} from the \textbf{Internal} topic can have the following values:

\begin{itemize}
   \item \textbf{Sync}: message contains the current state of the related \textit{ContextType}, used to populate a container's state;
   \item \textbf{Info}: message contains information about an entry of the related \textit{ContextType}, e.g. entry X in context Y was removed;
   \item \textbf{Unknown}: message contains entry of the related \textit{ContextType} that the container that published the message can't identify;
   \item \textbf{Init}: message to notify that a container has initiated and needs the current state of the related \textit{ContextType} to be ready;
   \item \textbf{Ping}: message to notify that an entry of the related \textit{ContextType} was used, e.g. entry X in context Y was just used.
\end{itemize}

The \textit{ContextType}, used to identity what piece of the state is referenced can have the following values: (i) \textit{Data Processor}, (ii) \textit{Data Decoder}, (iii) \textit{Device Information}, (iv) \textit{Device Identity}, (v) \textit{Tenant Identity}, (vi) \textit{Addressee Configuration} and (vii) \textit{Rule Management}.

Routing keys help to strengthen the boundaries that a container is expected to have. As an example, a Service in the \textbf{Service Scope} related to Waste Management would subscribe to the \textit{Data Topic} with the following \textit{Routing Keys}: 

\begin{itemize}
   \item \textit{Info Type Options}: PROCESSED;
   \item \textit{Channel Options}: 'wasteManagement';
   \item \textit{Data Legitimacy Options}: CORRECT;
   \item \textit{GPS Data Options}: WITH;
   \item \textit{Occupation Data Options}: WITH;
   \item \textit{Records Options}: WITH;
   \item \textit{Ownership Options}: WITH;
\end{itemize}

And would, for example, subscribe to the \textit{Alert Topic} with the following \textit{Routing Keys}:

\begin{itemize}
   \item \textit{Alert Category Options}: 'wasteManagement';
   \item \textit{Alert SubCategory Options}: 'garbageFull'; 
   \item \textit{Ownership Options}: WITH;
\end{itemize}

As expected, the structure and semantics of the information subscribed to are known upfront with the help of the package \textit{iot-core}.

\subsection{Bounded Contexts}
\label{subsec:design:domain:bounded_contexts}

The \textbf{Bounded Context} concept, defined by \cite{evans2014domain}, refers to an unified model - with well-defined boundaries and internally consistent - that is a single piece in a  larger system composed by various bounded contexts.

In this project, each Bounded Context can be pictured as a core business process of the system or as a simple service that addresses a specific business case.

The \textbf{Sensae Console} is composed by the following bounded contexts:

\begin{itemize}
   \item In \textbf{Configuration/Data Flow Scopes}:
   \begin{itemize}
      \item Data Processor;
      \item Data Decoder;
      \item Device Management;
      \item Identity Management;
      \item Rule Management.
   \end{itemize}
   \item In \textbf{Service Scope}:
   \begin{itemize}
      \item Smart Irrigation;
      \item Fleet Management;
      \item Notification Management.
   \end{itemize}
\end{itemize}

Each of this contexts will be briefly addressed in the following sections.

\subsubsection*{Data Processor}
\label{subsubsec:design:domain:bounded_contexts:processor}

The \textbf{Data Processor} context refers to simple data mappers that translate inbound information to \textbf{Data Unit}s, discussed in Section~\ref{subsubsec:design:domain:shared_model:data}.

The received information must be \textit{decoded}, meaning that the inbound information simply has a different structure than \textbf{Data Unit}.

The diagram in Figure~\ref{fig:design:domain:bounded_contexts:processor:diagram} displays the noteworthy concepts in this context.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/data-processor-model.latex}
  }
  \caption[Data Processor Context Model]{Data Processor Context Model}
  \label{fig:design:domain:bounded_contexts:processor:diagram}
\end{figure}

As a brief description:

\begin{itemize}
   \item \textbf{DataMapper}, the root entity in this context is identified by a \textbf{DeviceTypeId} and has various instructions to map properties from the inbound information to a \textbf{Data Unit} properties;
   \item \textbf{DeviceTypeId} corresponds to the \textbf{Routing Key} \textit{Device Type Options} mentioned in Table~\ref{tab:design:domain:shared_model:routing};
   \item \textbf{SubDeviceReference} represents a number that will be used later to reference a sub device when dealing with \textbf{Controller}s. For simple \textbf{Devices} the used and default value is \textit{0}; 
   \item \textbf{PropertyName} has much more properties that haven't been presented for brevity.
\end{itemize}

As an example, one could define an inbound information as a JSON document with the structure in the example \ref{code:design:domain:bounded_contexts:processor:json}. 

To map the \textit{temperature} value to the \textbf{TEMPERATURE\_CELSIUS} property of a \textbf{Data Unit} the \textbf{EncodedDataPropertyPath} would be \textit{decoded.data[0].temperature}.

\begin{lstlisting}[caption=Inbound Information Example, label={code:design:domain:bounded_contexts:processor:json}]
{
   "uuid": "de1a9d15-c018-4547-8453-87111cb4f81b",
   "id": "d81e6e69-1955-48a1-a1dd-4c812c15ebac",
   "time": 1657646955748,
   "decoded": {
      "data": [
         {
            "temperature": 18,
         }
      ]
   }
}
\end{lstlisting}

This process is simple since it expects the inbound information to be predisposed, but when working with \gls{IoT} Devices, to optimize the bandwidth used, it is common to send information encoded. The following section presents an alternative to this process.   

\subsubsection*{Data Decoder}
\label{subsubsec:design:domain:bounded_contexts:decoder}

The \textbf{Data Decoder} context refers to a more complex data mapper that translates inbound information to \textbf{Data Unit}s, discussed in Section~\ref{subsubsec:design:domain:shared_model:data}.
It was created to deal with the limitations mentioned in Section~\ref{subsubsec:design:domain:bounded_contexts:processor}.

The received information is usually \textit{encoded}, meaning that the inbound information is received as it was sent by the \textbf{Device}, commonly as a \textit{Base64} encoded string that needs to be processed so that information can be extracted.

The diagram in Figure~\ref{fig:design:domain:bounded_contexts:decoder:diagram} displays the noteworthy concepts in this context.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/data-decoder-model.latex}
  }
  \caption[Data Decoder Context Model]{Data Decoder Context Model}
  \label{fig:design:domain:bounded_contexts:decoder:diagram}
\end{figure}

As a brief description:

\begin{itemize}
   \item \textbf{DataDecoder}, the root entity in this context is identified by a \textbf{DeviceTypeId} and has a \textbf{Script};
   \item Currently a \textbf{Script} can only be written in \textit{JavaScript} but in the future more languages like \textit{Python} or \textit{Groovy} can be added;
   \item The \textbf{ScriptContent} contains the code that will run for each inbound information that matches the \textbf{DeviceTypeId}.
\end{itemize}

This process requires some programming language knowledge but is much more flexible than the \textbf{Data Processor} operation.

\subsubsection*{Device Management}
\label{subsubsec:design:domain:bounded_contexts:device}

The \textbf{Device Management} context refers to the inventory of all registered \textbf{Device}s in the \textbf{Sensae Console}.

The diagram in Figure~\ref{fig:design:domain:bounded_contexts:device:diagram} displays the noteworthy concepts in this context.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/device-management-model.latex}
  }
  \caption[Device Management Context Model]{Device Management Context Model}
  \label{fig:design:domain:bounded_contexts:device:diagram}
\end{figure}

As a brief description:

\begin{itemize}
   \item A \textbf{Device} is uniquely identified by a \textbf{DeviceId}, has a \textbf{DeviceName} and may have a \textbf{DeviceDownlink};
   \item A \textbf{DeviceCommand} defines how to send a \textbf{Downlink} with a specific action;
   \item A \textbf{DeviceStaticData} helps to define data such as the device location;
   \item A \textbf{DeviceRecord} enriches the device information with anything deemed important. This can also help to group devices by projects, type of utility and others;
   \item A \textbf{SubDevice} references another \textbf{Device} by its \textbf{DeviceId}. This, coupled with the concepts \textbf{SubDeviceMeasures} and \textbf{SubDeviceCommands} presented in Figure~\ref{fig:design:domain:shared_model:data:diagram} help to split a \textbf{Controller}'s \textbf{Data Unit} into various \textbf{Data Unit}, one for each referenced \textbf{SubDevice}.
\end{itemize}

\subsubsection*{Identity Management}
\label{subsubsec:design:domain:bounded_contexts:identity}

The \textbf{Identity Management} is concerned with identifying \textbf{Tenant}s, defining their permissions and what \textbf{Device}s they own.
To simplify this, a forth concept is introduced: \textbf{Domain}.

The diagram in Figure~\ref{fig:design:domain:bounded_contexts:identity:diagram} displays the noteworthy concepts in this context.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/identity-management-model.latex}
  }
  \caption[Identity Management Context Model]{Identity Management Context Model}
  \label{fig:design:domain:bounded_contexts:identity:diagram}
\end{figure}

As a brief description:

\begin{itemize}
   \item A \textbf{Domain} is uniquely identified by a \textbf{DomainId} and can have a parent \textbf{Domain};
   \item There's a root \textbf{Domain}, the only one that doesn't have a parent and has all the available permissions;
   \item A \textbf{Tenant} has a \textbf{TenantName} and \textbf{TenantEmail}, unique \textbf{TenantId} and can have a \textbf{TenantPhoneNumber};
   \item A special \textbf{Tenant}, Anonymous, exists by default to give access to users without an account in the platform;
   \item A \textbf{Device} is uniquely identified by a \textbf{DeviceId};
   \item The \textbf{PermissionType} has much more types that haven't been presented for brevity.
\end{itemize}

A \textbf{Domain} represents a department in a hierarchical organization. An organization is composed by several domains in a tree like structure as presented in Figure~\ref{fig:design:domain:bounded_contexts:identity:organization}.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/organization.latex}
  }
  \caption[Domain Structure]{Domain Structure}
  \label{fig:design:domain:bounded_contexts:identity:organization}
\end{figure}

Coupled with the figure above, there are other constrains:

\begin{itemize}
   \item A domain owns all devices in it and in his subdomains;
   \item A domain can only inherit his parent domain permissions;
   \item A tenant has all the domain permissions that he is registered in;
   \item A tenant can only see the devices that the domains he is registered in has access to;
   \item All \textit{Unallocated} domains have no permissions or devices and contain only tenants that are waiting to be assigned to a department or organization;
   \item The creation of an \textit{Organization} (level 2 domain), triggers the creation of its \textit{Unallocated} domain;
   \item The \textit{Public} domain can be accessed by any tenant, including those who are not authenticated in the system - with the Anonymous User account;
\end{itemize}

By default this context contains the \textit{Root Organization} domain, the \textit{Root Organization}'s  \textit{Unallocated} domain and the \textit{Public} domain.

Referring to the roles in Section~\ref{sec:requirements:functional}, a Manager belongs to the \textit{Root Organization}, any Costumer belongs to one or various \textit{Organization}s, and the Anonymous user belongs to the \textit{Public} domain.
Ultimately, what defines a user role is the domain he belongs to.Even if an \textit{Organization} ends up having all available permissions it will not be able to control or access other \textit{Organization}'s device data or employees information.

\subsubsection*{Rule Management}
\label{subsubsec:design:domain:bounded_contexts:rule}

The \textbf{Rule Management} context refers to rule scenarios.

The purpose of this context is to provide a high-level language that can analyze a stream of \textbf{Data Unit}s, identify abnormal occurrences, and output \textbf{Alert}s base on them. This systems are usually categorized as \gls{IFP} Systems, according to \cite{cugola2012processing}.

The following diagram, Figure~\ref{fig:design:domain:bounded_contexts:rule:ifp}, represents this systems.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/ifp-system.latex}
  }
  \caption[High-Level View of a \gls{IFP} System]{High-Level View of a \gls{IFP} System}
  \label{fig:design:domain:bounded_contexts:rule:ifp}
\end{figure}

In this specific solution, the input data are \textbf{Data Unit}s and the output data are the \textbf{Alert}s. This context is concerned about how \textit{rules} are defined, the diagram in Figure~\ref{fig:design:domain:bounded_contexts:rule:diagram} displays the noteworthy concepts.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/rule-management-model.latex}
  }
  \caption[Rule Management Context Model]{Rule Management Context Model}
  \label{fig:design:domain:bounded_contexts:rule:diagram}
\end{figure}

\subsubsection*{Notification Management}
\label{subsubsec:design:domain:bounded_contexts:notification}

The \textbf{Notification Management} context refers to notifications and how/what types an addressee wants to receive. There are two main concepts in this context, a notification and an addressee.

The diagram in Figure~\ref{fig:design:domain:bounded_contexts:notification:diagram} displays the noteworthy concepts in this context.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/notification-management-model.latex}
  }
  \caption[Notification Management Context Model]{Notification Management Context Model}
  \label{fig:design:domain:bounded_contexts:notification:diagram}
\end{figure}
 
As a brief description:

\begin{itemize}
   \item A \textbf{Notification} is a sanitized \textbf{Alert} that was captured with the intent to be presented or delivered to addressees, its identified by an \textbf{NotificationId};
   \item An \textbf{Addressee} is someone that receives notifications based on his configurations and is identified by an \textbf{AddresseeId};
   \item An \textbf{AddresseeConfiguration} defines for each type of notification - \textbf{ContentType} - what will be the delivery method - \textbf{DeliveryType};
   \item A \textbf{DeliveryType} can be of four types: (i) present in SPA - \textbf{UI}, (ii) publish notification in SPA - \textbf{NOTIFICATION}, (iii) send an email - \textbf{EMAIL}, (iv) send an SMS - \textbf{SMS}; 
   \item A \textbf{ContentType} is derived from the \textbf{Alert} Routing Keys mentioned in the Table~\ref{tab:design:domain:shared_model:routing} and defines the type of each \textbf{Notification};
   \item A \textbf{NotificationContext} is data that can help to correlate the \textbf{Notification} with other contexts such as what devices - \textbf{DeviceIdContext} - were involved in the \textbf{Alert} trigger, or what domains - \textbf{DomainIdContext} - need to be notified, or what \textbf{Data Unit}s - \textbf{DataIdContext} - are related to the \textbf{Alert};
   \item To enforce accountability in the system, the notion of who read a specific notification and when was added - \textbf{NotificationRead}.
\end{itemize}

\subsubsection*{Smart Irrigation}
\label{subsubsec:design:domain:bounded_contexts:irrigation}

The \textbf{Smart Irrigation} context refers to irrigation zones, sensors that read environmental conditions in this zones, valves and the associated readings. This concepts are divided in three diagrams presented below.

The diagram in Figure~\ref{fig:design:domain:bounded_contexts:irrigation:diagram:garden} displays the noteworthy concepts related to irrigation zones.

An irrigation zone is an area intended to function as an isolated environment that may or may not have valves or sensors.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/smart-irrigation-model-2.latex}
  }
  \caption[Smart Irrigation Context Model - Irrigation Zone]{Smart Irrigation Context Model - Irrigation Zone}
  \label{fig:design:domain:bounded_contexts:irrigation:diagram:garden}
\end{figure}

A sensor or valve belongs to an irrigation zone if it is inside the zone's \textbf{Area}.

As presented in the following diagram, Figure~\ref{fig:design:domain:bounded_contexts:irrigation:diagram:device}, a sensor/valve can be represents by a \textbf{Device}.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/smart-irrigation-model-3.latex}
  }
  \caption[Smart Irrigation Context Model - Device]{Smart Irrigation Context Model - Device}
  \label{fig:design:domain:bounded_contexts:irrigation:diagram:device}
\end{figure}

As a brief description:

\begin{itemize}
   \item A \textbf{Valve} can be controlled remotely if two types of \textbf{Command}s are sent with the device \textbf{Data Unit}: \textit{OpenValve} and \textit{CloseValve};
   \item A \textbf{Device} is identified by its \textbf{DeviceId};
   \item Each \textbf{Device} stores an history of all its changes such as name, location or metadata in \textbf{Content}, the same \textbf{LedgerEntry} is used as long as this values don't change;
   \item There are three types of \textbf{Device}: (i) Green House Sensor, (ii) Park Sensor, (iii) Valve. Each of this types collect different measures discussed in Figure\ref{fig:design:domain:bounded_contexts:irrigation:diagram:reading}.
\end{itemize}

As mentioned above each type of device collects different readings. The following diagram, Figure\ref{fig:design:domain:bounded_contexts:irrigation:diagram:reading}, details this readings.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/smart-irrigation-model-4.latex}
  }
  \caption[Smart Irrigation Context Model - Reading]{Smart Irrigation Context Model - Reading}
  \label{fig:design:domain:bounded_contexts:irrigation:diagram:reading}
\end{figure}

As a brief description:

\begin{itemize}
   \item A \textbf{Reading} is always identified by its \textbf{ReadingId} and is associated to the instant that it was captured by the \textbf{Device} - \textbf{ReportedTime};
   \item A \textbf{ParkSensorReading} measures soil moisture and illuminance;
   \item A \textbf{Valve} indicates if it is open or closed;
   \item A \textbf{GreenHouseSensor} measures air humidity and air temperature.
\end{itemize}

The concepts in this last diagram are different from the concepts in the other two diagram since readings data is suppose to be immutable and ample as opposed to devices and irrigation zones where information should be mutable but with a negligible size compared with readings.

\subsubsection*{Fleet Management}
\label{subsubsec:design:domain:bounded_contexts:fleet}

The \textbf{Fleet Management} context simply refers to the past and current location of assets. 

The diagram in Figure~\ref{fig:design:domain:bounded_contexts:fleet:diagram} displays the noteworthy concepts related to this context.

\begin{figure}[H]
   \centering
  \resizebox{\columnwidth}{!}
  {
     \input{assets/diagrams/design/domain/fleet-management-model.latex}
  }
  \caption[Fleet Management Context Model]{Fleet Management Context Model}
  \label{fig:design:domain:bounded_contexts:fleet:diagram}
\end{figure}

This was the first \textit{Service} built as an \gls{MVP}, it was intended to be straightforward. The model references \gls{GPS} readings and what device collected them.

\subsection{Synopsis}
\label{subsec:design:domain:synopsis}

In this section the various domains that \textbf{Sensae Console} incorporates are described. This domains share some concepts such as \textbf{Device} but it isn't clear how they interact with each other. In the next section - \nameref{sec:design:architecture} - it will be addressed how this domains are connected and cooperate.

\section{Architectural Design}
\label{sec:design:architecture}

In order to describe the system in detail at the architectural level, an approach based on the combination of two models, C4 (\cite{c4model-site}) and 4+1  will be followed.

The 4+1 View Model (\cite{4plus1model}), proposes the description of the system through complementary views thus allowing to separately analyze the requirements of various software stakeholders, such as users, system administrators, project managers, architects, and programmers.

The five views are thus defined as follows:
\begin{itemize}
   \item \textbf{Logical view}: relative to the aspects of the software aimed at responding to business challenges;
   \item \textbf{Process view}: relative to the process flow or interactions within the system;
   \item \textbf{Development view}: relative to the organization of the software in its development environment;
   \item \textbf{Physical view}: relative to the mapping of the various components of the software in hardware, i.e. where the software is executed;
   \item \textbf{Scenario view}: related to the association of business processes with actors capable of triggering them.
\end{itemize}

The C4 Model (\cite{c4model-site}, \cite{c4model}) advocates describing software through four levels of abstraction:
(i) system, (ii) container, (iii) component, (iv) code. Each level adopts a finer granularity than the level that precedes it, thus giving access to more details of a smaller portion of the system.
These levels can be likened to maps, e.g. the system view corresponds to the globe, the container corresponds to the map of each continent, the component view corresponds to the map of each of each country, and the code view to the map of roads and neighborhoods in each city.

Different levels allow you to tell different stories to different audiences.

The levels are defined as follows:
\begin{itemize}
   \item \textbf{Level 1}: Description (context) of the system as a whole;
   \item \textbf{Level 2}: Description of system containers;
   \item \textbf{Level 3}: Description of components of the containers;
   \item \textbf{Level 4}: Description of the code or smaller parts of the components.
\end{itemize}

These two models can be said to expand along distinct axes, with the
C4 Model presenting the system with different levels of detail and the 4+1 View Model presents the system from different perspectives. By combining the two models it becomes possible to represent the system from several perspectives, each with various levels of detail.
To visually model/represent the ideas designed and alternatives considered, the \gls{UML} was used.

In the following sections only combinations of perspectives and level deemed relevant for the design of the solution are presented.

The C4 level 4, code, will not be exhibited.

\subsection{C4 Level 1 - Context}
\label{subsec:design:architecture:context}

The context level aims at introducing the system as a whole. The external systems and users that communicate/interact with the system, \textbf{Sensae Console}, are demonstrated.
Throughout this section the relevant C4 views of level 1 (context level) are presented.

\subsubsection*{Context Level - Logical View}
\label{subsubsec:design:architecture:context:logical}

The logical view of the system is introduced here, complete but not detailed, in order to answer the use cases and requirements discussed in Chapter~\ref{chap:requirements}. This takes into account the interactions of the platform with external systems and its interaction with the various actors of the system (Figure~\ref{fig:design:architecture:context:logical:diagram}).

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level1/logical-view.latex}
   }
   \caption[Context Level - Logical View Diagram]{Context Level - Logical View Diagram}
   \label{fig:design:architecture:context:logical:diagram}
\end{figure}

The external systems and its functions are as follows:
\begin{itemize}
   \item \textbf{Helium Console}: Device data hub;
   \item \textbf{Azure Active Directory}: User authentication/identity;
   \item \textbf{Google Identity Platform}: User authentication/identity;
   \item \textbf{Twilio Platform}: SMS delivery;
   \item \textbf{Google Email Platform}: Email delivery.
\end{itemize}

The reason behind the use of external authentication/identity services is described in the Section~\ref{subsec:design:alternatives:auth}.

\subsubsection*{Context Level - Development View}
\label{subsubsec:design:architecture:context:development}

Next is the development view (Figure~\ref{fig:design:architecture:context:development:diagram}), intended to familiarize the reader with how the software is organized.

\begin{figure}[H]
   \centering
      \input{assets/diagrams/design/architectural/level1/development-view.latex}
   \caption[Context Level - Development View Diagram]{Context Level - Development View Diagram}
   \label{fig:design:architecture:context:development:diagram}
\end{figure}

The package \textit{iot-core} contains the shared model discussed in the Section~\ref{subsec:design:domain:shared_model}, and defines what type of information backend containers can subscribe to or publish (discussed in Section~\ref{subsec:design:domain:taxonomy}).

The package \textit{sensae-console} contains software of the various containers needed to run the \textbf{Sensae Console}. As expected \textit{iot-core} is a core dependency for the \textit{sensae-console} backend containers.

\subsubsection*{Context Level - Physical View}
\label{subsubsec:design:architecture:context:physical}

Next is the physical view (Figure~\ref{fig:design:architecture:context:physical:diagram}), intended to familiarize the reader with the environment where the solution runs.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level1/physical-view.latex}
   }
   \caption[Context Level - Physical View Diagram]{Context Level - Physical View Diagram}
   \label{fig:design:architecture:context:physical:diagram}
\end{figure}

\subsubsection*{Context Level - Synopsis}
\label{subsubsec:design:architecture:context:synopsis}

The context level introduces the reader to the bigger picture of \textbf{Sensae Console}, but it contains little to no information about how the system functions internally, the Section~\ref{subsec:design:architecture:containers} will dive into this subject.

The process view was not represented since at this level the interactions between the system, actors and external systems, are too abstract to be relevant for the reader.

\subsection{C4 Level 2 - Containers}
\label{subsec:design:architecture:containers}

The C4 level 2 introduces the reader to the various containers that compose the system. In this section all relevant views will be presented according to the alternative in use or idealized for the system. In the Section~\ref{sec:design:alternatives} other alternatives are discussed. 

The Physical View will not be represented since the fundamental idea behind the idealized deployment of \textbf{Sensae Console} is already described in the Section \nameref{subsubsec:design:architecture:context:physical}.

\subsubsection*{Container Level - Logical View}
\label{subsubsec:design:architecture:container:logical}

The description of this level of abstraction begins with a logical view of the containers that compose the system. Alternatives were also analyzed taking into account several requirements namely (i) configurability, (ii) maintainability, (iii) extensibility (iv) development cost and (v) scalability.

In order to support the functional requirements identified (Section~\ref{sec:requirements:functional}), and knowing that \textbf{Sensae Console} will serve multiple users with different levels of access to the managed information, the various business concepts were segregated from the user interaction. The business management also had to be separated from the  data pipeline, knowing that \textbf{Sensae Console} will process a high level of device data.

Considering the need to persist and provide the information collected, the system integrates databases, which are not developed, but only configured and operated - using a \gls{DBMS}.

The system also uses one (or more) message brokers, \cite{broker}, that will be configured but not developed.

In order to ease the analysis of the system the following diagrams will be divided by scopes, mentioned in \ref{sec:design:system_scopes}. In the Appendix~\ref{AppendixB} a complete logical view is provided.

The logical view of the \textbf{Configuration Scope} is represented in Figure~\ref{fig:design:architecture:container:logical:diagram:configuration}. This scope is composed by the processes discussed in \ref{subsec:design:system_scopes:configuration_scope}. Each process is composed by a three tier architecture, as per \cite{3tier}:

\begin{itemize}
   \item \textbf{Presentation Tier}: the user interface and communication tier of the application where the user interacts with the system;
   \item \textbf{Application Tier}: the business tier of the application where information from the \textbf{Presentation Tier} is processed and sent to the \textbf{Data Tier};
   \item \textbf{Data Tier}: the infrastructure tier of the application where data is stored and requested as needed. 
\end{itemize}

This scope was also divided into micro services - \cite{newman2021building} - \textit{'small, autonomous services that work together'}. Each bounded context/business process - (i) Data Processor, (ii) Data Decoder, (iii) Device Management, (iv) Identity Management, (v) Rule Management - is mapped to the three tier architecture mention before.

\begin{landscape}
   \begin{figure}[H]
      \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/logical/configuration.latex}
   }
   \caption[Container Level - Configuration Scope - Logical View Diagram]{Container Level - Configuration Scope - Logical View Diagram}
      \label{fig:design:architecture:container:logical:diagram:configuration}
   \end{figure}
\end{landscape}

As a brief description:

\begin{itemize}
   \item Frontend containers correspond to the \textbf{Presentation Tier} and are provided to the user though \textbf{UI Aggregator};
   \item Backend containers correspond to the \textbf{Application Tier} and communication with each other though \textbf{Message Broker};
   \item Database containers correspond to the \textbf{Data Tier}.
\end{itemize}

Next, the logical view of the \textbf{Data Flow} is represented in Figure~\ref{fig:design:architecture:container:logical:diagram:data_flow}. This scope is composed by the processes discussed in \ref{subsec:design:system_scopes:data_flow_scope}. In parallel with the \textbf{Configuration Scope} this scope is also divided into multiple micro services in order for them to better scale once needed. This scope is also built based on a \textit{Reactive architecture} as described in \cite{reactivemanifesto} and \cite{reactivesystem}.  

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/logical/data-flow.latex}
   }
   \caption[Container Level - Data Flow Scope - Logical View Diagram]{Container Level - Data Flow Scope - Logical View Diagram}
   \label{fig:design:architecture:container:logical:diagram:data_flow}
\end{figure}

Most containers presented here collect specific information from a single backend in the \textbf{Configuration Scope} though the \textit{Internal} Topic:

\begin{itemize}
   \item \textbf{Data Processor Flow Backend}: Collects information related to the \textbf{Data Processor} context - published by \textbf{Data Processor Backend} - and noting else;
   \item \textbf{Data Decoder Flow Backend}: Collects information related to the \textbf{Data Decoder} context - published by \textbf{Data Decoder Backend} - and noting else;
   \item \textbf{Device Ownership Backend}: Collects information related to the \textbf{Identity Management} context (more specifically device ownership) - published by \textbf{Identity Management Backend} - and noting else;
   \item \textbf{Device Management Flow Backend}: Collects information related to the \textbf{Device Management} context - published by \textbf{Device Management Backend} - and noting else;
   \item \textbf{Alert Dispatcher Backend}: Collects information related to the \textbf{Rule Management} context - published by \textbf{Rule Management Backend} - and noting else;
   \item \textbf{Device Command Backend}: Collects information related to the \textbf{Device Management} context - published by \textbf{Device Management Backend} - and noting else;
   \item The remaining containers don't subscribe to any type of information from the \textbf{Configuration Scope}.
\end{itemize}

Finally the \textbf{Service Scope} is represented in Figure~\ref{fig:design:architecture:container:logical:diagram:service}. This scope is composed by the processes discussed in \ref{subsec:design:system_scopes:service_scope}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/logical/service.latex}
   }
   \caption[Container Level - Service Scope - Logical View Diagram]{Container Level - Service Scope - Logical View Diagram}
   \label{fig:design:architecture:container:logical:diagram:service}
\end{figure}

Once again the ideas behind this scope architecture are the same discussed in the \textbf{Configuration Scope} apart from two particular points:

\begin{itemize}
   \item \textbf{Smart Irrigation Data Database/Business Database}: As explained in the domain presented in \ref{subsubsec:design:domain:bounded_contexts:irrigation}, since there are two distinct types of information to store and manage it was decided to use different technologies for each type;
   \item \textbf{Notification Management/Dispatcher Backend}: It was also decided to split the delivery of notifications (by email and SMS) from the management of them. 
\end{itemize}

Lastly, as we can seen some containers are present in more than one scope, this containers, and their responsibilities are:

\begin{itemize}
   \item \textbf{Message Broker}: Container responsible for routing messages/events sent by backend containers. This communication is explored in the section, \nameref{subsubsec:design:architecture:container:process};
   \item \textbf{UI Aggregator}: Container responsible for aggregating all frontends in a single \gls{UI}.
\end{itemize}

In the following section the internal communication of the system is clarified.

\subsubsection*{Container Level - Process View}
\label{subsubsec:design:architecture:container:process}

In this section several use cases (according to some functional requirements identified in Section~\ref{sec:requirements:functional}) are presented through sequence diagrams, in order to introduce the reader to the interactions that occur between the various containers of the \textbf{Sensae Console}. 

The routing keys used for communication between backend containers can be extrapolated from the model described in the Section~\ref{subsubsec:design:domain:shared_model:routing}. 

This section is composed by five sets of important functionalities to discuss at this level of abstraction: (i) system/container initialization (ii) data pipeline operation, (iii) data pipeline configuration, (iv) user authentication/authorization, (v) service usage.

The system/container initialization, presented in Figure~\ref{fig:design:architecture:container:process:diagram:init}, refers to the interval of time since a container is launched till it is ready to process requests or events.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/container-init.latex}
   }
   \caption[Container Level - System/Container Initialization - Process View Diagram]{Container Level - System/Container Initialization - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:init}
\end{figure}

Not all containers are displayed in this diagram for brevity reasons.
The system relies heavily in the Pub/Sub (\cite{pubsub}) pattern to communicate internally via a message broker. In this scenarios the first step in a container life cycle is to subscribe to the information that it needs as presented in the diagram above.

Certain containers need the entire state related to their \textit{ContextType} to function. So, after subscribing to the needed information, they notify the system that they have entered an \textit{init state} for a specific context. This triggers the creation of new events to help that container to reach a \textit{ready state}. An example of this interaction is presented in the following diagram, Figure~\ref{fig:design:architecture:container:process:diagram:ready},note that this only occurs in the Internal Topic.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/container-ready.latex}
   }
   \caption[Container Level - System/Container Initialization - Part 2 - Process View Diagram]{Container Level - System/Container Initialization - Part 2 - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:ready}
\end{figure}

Apart from the Alert Dispatcher Backend all containers in the \textbf{Data Flow Scope} benefit from a stateless process and can function with just a portion of a single \textit{ContextType} state or no state at all.

To dive into this some common data pipeline operations, related to the Data Flow Scope, are presented next. This operations are intended to behave in a \textit{reactive} manner (\cite{reactivemanifesto}) and are therefore non-blocking. The idea behind the Data Flow Scope is analog to a data pipeline. This scope operates mostly on Data Units, transforming, filtering and enriching this data.

The following diagram in Figure~\ref{fig:design:architecture:container:process:diagram:flow} presents a high level view of the flow that a Data Unit takes through the system in the Data topic. This diagram does not account for what happens to invalid Data Units and the interactions with the message broker are hidden for brevity reasons even tho it is used by all containers but the Data Relayer to publish messages.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/data-flow-scope.latex}
   }
   \caption[Container Level - Data Flow - Diagram]{Container Level - Data Flow - Diagram}
   \label{fig:design:architecture:container:process:diagram:flow}
\end{figure}

Most of this containers have just a portion of their context state and may be unable to preform the needed operation on some Data Units. The following diagrams, Figure~\ref{fig:design:architecture:container:process:diagram:decoder:1} and Figure~\ref{fig:design:architecture:container:process:diagram:decoder:2}, addresses how state is managed in Data Decoder Flow Backend and most \textbf{Data Flow Scope} containers.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/data-decoder-flow-1.latex}
   }
   \caption[Container Level - Data Decoder Operation part 1 - Process View Diagram]{Container Level - Data Decoder Operation Part 1 - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:decoder:1}
\end{figure}

As we can see the Data Decoder Flow Backend, upon receiving a Data Unit, can preform two operations depending on the script being available or not: decode the Data Unit and notify that the script was used or store the Data Unit and notify that a script for an unknown device type is needed.

The next diagram demonstrates what happens when a decoder is published via the \textit{OperationType} Info.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/data-decoder-flow-2.latex}
   }
   \caption[Container Level - Data Decoder Operation Part 2 - Process View Diagram]{Container Level - Data Decoder Operation Part 2 - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:decoder:2}
\end{figure}

As we can see Data Decoder Flow Backend, upon receiving an info regarding a data decoder, searches for unhandled Data Units and processes them.
To minimize the memory in use, a data decoder has to be continually used in order for it to remain in cache. As seen in step \textbf{2.2}, if \textit{X} hours pass since the last time a decoder was used it is evicted from the container internal state.

The operations described here for the Data Decoder Flow Backend are replicated in the following contexts/containers:

\begin{itemize}
   \item \textbf{Data Processor Context}: Data Processor Flow Backend;
   \item \textbf{Device Management Context}: Device Management Flow Backend and Device Commander Backend;
   \item \textbf{Identity Management Context}: Device Ownership.
\end{itemize}

As described before, containers that belong to the \textbf{Data Flow Scope} are configured according to what is defined in the \textbf{Configuration Scope}.

The next diagrams, in Figure~\ref{fig:design:architecture:container:process:diagram:processor} and Figure~\ref{fig:design:architecture:container:process:diagram:device} present some of the common operations that happen in that scope.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/consult-data-processor.latex}
   }
   \caption[Container Level - Consult Data Processors - Process View Diagram]{Container Level - Consult Data Processors - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:processor}
\end{figure}

The diagram presented above represents a simple consult of data mappers, as we can see, only the Data Processor Context in the Configuration Scope is invoked. When a change to the state is made in any Context of the Configuration Scope events are published. The next diagram, Figure~\ref{fig:design:architecture:container:process:diagram:device} displays an example of this occurrence.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/edit-device-management.latex}
   }
   \caption[Container Level - Edit Device Information - Process View Diagram]{Container Level - Edit Device Information - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:device}
\end{figure}

In this use case a device information is changed. Since this operation changes the internal state of the device management context an event is published in the Internal Topic.

As an example this specific event, according to the Section~\ref{subsubsec:design:domain:shared_model:routing}, uses the following \textit{Routing Keys}:

\begin{itemize}
   \item \textbf{Protocol Version}: the version of \textit{iot-core} currently in use by Device Management Backend;
   \item \textbf{Container Type}: Device Management Backend;
   \item \textbf{Topic Type}: Internal;
   \item \textbf{Operation Type}: Info;
   \item \textbf{Context Type}: Device Management;
\end{itemize}

There are three containers that subscribe to this specific type of event:

\begin{itemize}
   \item \textbf{Device Management Flow Backend}: so that the Data Units of the device changed are enriched with the latest information;
   \item \textbf{Device Command Backend}: so that commands for this device are treated according to the latest information;
   \item \textbf{Identity Management Backend}: so that information related to the device changed is presented according to the latest update. This container maintains local copies of all devices names to present to the user without needing to request Device Management for that information every time.
\end{itemize}

The step \textbf{1.3} in the last two diagrams references user permissions but there is no mention of how this permissions are associated to the user. In the next diagrams - Figure~\ref{fig:design:architecture:container:process:diagram:authentication} and Figure~\ref{fig:design:architecture:container:process:diagram:authorization} - authentication and authorization in the \textbf{Sensae Console} are addressed, other approaches are discussed in the \nameref{subsec:design:alternatives:auth} Section.

The system verifies the identity of a user based on the authentication performed by an external \gls{CIAM} solution using OpenID Connect 1.0, \cite{openid}, an identity layer on top of the OAuth 2.0 protocol. According to \cite{oauth} OAuth2.0 \textit{"enables a third-party application to obtain limited access to an HTTP service"}. In this situation the Frontend of \textbf{Sensae Console} is the third-party application and the HTTP service is any of the \textbf{Sensae Console} backend services.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {      
      \input{assets/diagrams/design/architectural/level2/process/user-authentication.latex}
   }
   \caption[Container Level - User Authentication - Process View Diagram]{Container Level - User Authentication - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:authentication}
\end{figure}

This diagram illustrates how a user can authenticate against \textbf{Sensae Console}.
The user identity and credentials validation are assured by an external identity platform such as \citetitle{googleid} or \citetitle{azureid}. Once an \textit{id token} is provided to \textbf{Sensae Console} it can use it to verify the user identity against the local registry. To ensure that the \textit{id token} is valid, Identity Management Backend checks if it was signed by the platform that supposedly issued it (step \textbf{3.3} and \textbf{3.5}). After validating the \textit{id token} it searches for the needed information to create an \textit{access token} and then provides it. The \textit{access token} can then be used for a limited time to access any protected HTTP resource of \textbf{Sensae Console} as demonstrated in Figure~\ref{fig:design:architecture:container:process:diagram:authorization}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/process/user-authorization.latex}
   }
   \caption[Container Level - User Authorization - Process View Diagram]{Container Level - User Authorization - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:authorization}
\end{figure}

In this diagram the expected behavior for any pair of frontend and backend containers in \textbf{Configuration Scope} and \textbf{Service Scope} is presented. Each frontend displays only the actions and information that the user permissions allow. The user permissions are once again verified in the backend to secure the system against malicious accesses. Other alternatives related to authentication and authorization are presented in the Section~\ref{subsec:design:alternatives:auth}.

Finally some operations performed in the \textbf{Service Scope} are presented starting with how a user can see the current location of a device via the Fleet Management Service (Figure~\ref{fig:design:architecture:container:process:diagram:fleet}). Authentication details will be omitted for brevity reasons.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/process/device-live-location.latex}
   }
   \caption[Container Level - Consult Device Live Location via Fleet Management - Process View Diagram]{Container Level - Consult Device Live Location via Fleet Management - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:fleet}
\end{figure}

In order to provide live information to the user \textbf{Service Scope} services rely on \textit{WebSockets}. A bidirectional channel is created between the frontend and backend so that data can be sent directly from the backend to the frontend as we can see in the step \textbf{2.6}. Fist the frontend must subscribe to new information with a valid \textit{access token} - steps \textbf{1.2} to \textbf{1.6} - then this channel is maintained till the user leaves the page. Once the user leaves the page the subscription is closed in the frontend and subsequently in the backend - steps \textbf{3.2} to \textbf{3.5}.

The next diagram in Figure~\ref{fig:design:architecture:container:process:diagram:notification} describes how a user receives notifications via several different delivery channels. For brevity reasons the subscription process is omitted.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/process/notification-dispatch.latex}
   }
   \caption[Container Level - Receive notification via Notification Management - Process View Diagram]{Container Level - Receive notification via Notification Management - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:notification}
\end{figure}

As a brief description this diagram describes what happens when an alert is dispatched inside \textbf{Sensae Console}. An alert is created in Alert Dispatcher Backend, flows though Device Ownership Backend to be enriched with the domains that own it and is then collected by, at least, Notification Management Backend and Notification Dispatcher Backend. Notification Management Backend deliveries alerts in the form of \gls{UI} notifications - step \textbf{3.5} and \textbf{3.6} - and stores this alert as a notification for later use - step \textbf{3.3}. Notification Dispatcher Backend deliveries alerts in the form of Emails - step \textbf{4.4} - and SMS - step \textbf{4.7}.

Certain types of alerts are also collected by Smart Irrigation Backend to automatically control conditions inside an irrigation zone. In the next diagram, Figure \ref{fig:design:architecture:container:process:diagram:irrigation}, this process is presented.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/process/smart-irrigation.latex}
   }
   \caption[Container Level - Valve Activation Process via Smart Irrigation - Process View Diagram]{Container Level - Valve Activation Process via Smart Irrigation - Process View Diagram}
   \label{fig:design:architecture:container:process:diagram:irrigation}
\end{figure}

The alerts created in \textbf{Sensae Console} are captured by containers in the \textbf{Service Scope} so that they can act based on the alerts.

The Smart Irrigation Backend subscribes to three types of \textit{Sub Category} alerts all with the same \textit{Category} - \textit{Smart Irrigation}:

\begin{itemize}
   \item \textbf{Damped Environment}: a valve needs to be closed;
   \item \textbf{Dry Environment}: a valve needs to be open;
   \item \textbf{Valve Open For Lengthy Period}: a valve needs to be close.
\end{itemize}

\subsubsection*{Container Level - Development View}
\label{subsubsec:design:architecture:container:development}

Each container mentioned in the Section~\ref{subsec:design:architecture:containers} is developed inside the same package, \textit{sensae-console}. The following diagrams presents how containers are mapped to packages.

Frontend services are organized according to the diagram in Figure~\ref{fig:design:architecture:container:process:diagram:development:frontend}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/development/frontend.latex}
   }
   \caption[Container Level - Frontend Services - Development View Diagram]{Container Level - Frontend Services - Development View Diagram}
   \label{fig:design:architecture:container:process:diagram:development:frontend}
\end{figure}

Each frontend service is divided between the \textit{apps} package and \textit{libs} package. Each \textit{app} depends on the corresponding \textit{lib}. Every \textit{lib} depend on the \textit{core} and \textit{auth} packages. The UI Aggregator depends only on the \textit{auth} package.

Backend services are organized according to the diagram in Figure~\ref{fig:design:architecture:container:process:diagram:development:backend}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/development/backend.latex}
   }
   \caption[Container Level - Backend Services - Development View Diagram]{Container Level - Backend Services - Development View Diagram}
   \label{fig:design:architecture:container:process:diagram:development:backend}
\end{figure}

Each backend service software lives inside its own package. All containers have been develop besides the \textit{Data Relayer} that was only configured.

Database services are organized according to the diagram in Figure~\ref{fig:design:architecture:container:process:diagram:development:backend}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/development/database.latex}
   }
   \caption[Container Level - Database Services - Development View Diagram]{Container Level - Database Services - Development View Diagram}
   \label{fig:design:architecture:container:process:diagram:development:database}
\end{figure}

No database service has been developed, only configured. The Fleet Management Database and Smart Irrigation Data Database needed no configuration and as such aren't associated with any package. The Message Broker also has no package in the project since it didn't need any configuration and wasn't developed.

\subsubsection*{Container Level - Physical View}
\label{subsubsec:design:architecture:container:physical}

Next is the physical view (Figure~\ref{fig:design:architecture:container:physical:diagram}), intended to familiarize the reader with the idealized production environment. Each container that composes the system is containerized via \textit{Docker} so that orchestration software like \textit{Docker Compose}, \textit{Docker Swarm}, \textit{Kubernetes} and \textit{OpenShift} can be used to ease the operation phase.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level2/physical/complete.latex}
   }
   \caption[Container Level - Physical View Diagram]{Container Level - Physical View Diagram}
   \label{fig:design:architecture:container:physical:diagram}
\end{figure}

Even though the diagram above represents a \textit{Kubernetes} cluster, the production environment is orchestrated using \textit{Docker Compose} running in a single node/server. This decision was taken after acknowledging that currently there is no need to scale the solution, a single node has been capable of handling all throughput.

Each Container represented in Section~\ref{subsubsec:design:architecture:container:logical} is mapped to a container in this view. Following the \citetitle{dbperservice}, each logical database also corresponds to a physical database. 

\subsubsection*{Container Level - Synopsis}
\label{subsubsec:design:architecture:container:synopsis}

The container level introduces the reader to the internals of \textbf{Sensae Console}. Each container is introduced and the interactions between them are explored.
In the following section, Section~\ref{subsec:design:architecture:components}, the developed containers are presented with a granularity of level 3 (in the C4 model).

\subsection{C4 Level 3 - Components}
\label{subsec:design:architecture:components}

The component level describes the internals of a specific container. A container is made up of a number of components, each with well-defined responsibilities. In the following diagrams the dependencies between the various components will also be presented.

Most developed containers share the same architecture and will therefore be addressed as groups of containers.

The physical view will not be presented since all relevant details have been addressed above.

\subsubsection*{Components Level - Logical View}
\label{subsubsec:design:architecture:components:logical}

The architectures used in the various developed containers can be condensate into 3 types with minor variations:

\begin{itemize}
   \item \textbf{Frontend Architecture}: used on all frontend containers;
   \item \textbf{Management Backend Architecture}: used on most service scope backend containers and all configuration scope backends; 
   \item \textbf{Data Flow Architecture}: used on most containers related to the Data Flow scope.
\end{itemize}

Starting with the Frontend Architecture used, it was decided to maintain two distinct domains, Model and DTOS, in order to meet the \gls{SRP} (high cohesion) and to lower the coupling between the information displayed in the UI and the data sent/received by the container. This segmentation led to the addition of the Mapper component, which has the responsibility of converting the data (DTOS component) into information (Model component) and vice-versa. The Auth component indicates what backend resources the user has access to and the Utils component has several methods commonly used to process backend requests, this two components are reused in all frontend containers.

As an example the logical view of the Data Decoder Frontend is presented in Figure~\ref{fig:design:architecture:component:logical:diagram:decoder}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/logical/data-decoder-frontend.latex}
   }
   \caption[Component Level - Data Decoder Frontend - Logical View Diagram]{Component Level - Data Decoder Frontend - Logical View Diagram}
   \label{fig:design:architecture:component:logical:diagram:decoder}
\end{figure}

This architecture is used on the containers: (i) Device Management Frontend, (ii) Data Decoder Frontend, (iii) Data Processor Frontend, (iv) Notification Management Frontend, (v) Identity Management Frontend, (vi) Rule Management Frontend, (vii) Fleet Management Frontend and (viii) Smart Irrigation Frontend. The UI Aggregator has a simpler architecture them the other frontend containers, it is comprised by a Presentation component that depends on the Auth component to handle user authentication and authorization.

Next, the Management Backend Architecture is discussed. It is based on the Onion Architecture, an architecture pattern that "emphasizes separation of concerns throughout the system" and "leads to more maintainable applications" (\cite{onion}).

As an example the logical view of the Device Management Backend is presented in Figure~\ref{fig:design:architecture:component:logical:diagram:device}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/logical/device-management-backend.latex}
   }
   \caption[Component Level - Device Management Backend - Logical View Diagram]{Component Level - Device Management Backend - Logical View Diagram}
   \label{fig:design:architecture:component:logical:diagram:device}
\end{figure}

This architecture is used on the containers: (i) Device Management Backend, (ii) Data Decoder Backend, (iii) Data Processor Backend, (iv) Notification Management Backend, (v) Identity Management Backend, (vi) Rule Management Backend and (vii) Fleet Management Backend. The Smart Irrigation Backend has an additional component - QuestDB - inside the Persistence component with the same dependencies as the Postgres component. The Notification Dispatcher's architecture also differs from the architecture here presented. Further details of these differences can be consulted in Appendix ~\ref{AppendixC}.

The following table, Table~\ref{tab:design:architecture:components:logical:backend}, discusses each component responsibilities.

\begin{table}[H]
   \begin{tabular}{@{}cl@{}}
   \toprule
   \textbf{Component}               & \textbf{Responsibilities}                                            \\ \midrule
   Infrastructure &
     \begin{tabular}[c]{@{}l@{}}- Enclose components that manage the Input/Output\\ operations required by the container;\end{tabular} \\ \midrule
   \multirow{3}{*}{Boot}            & - Manage the start up of the container;                              \\
    &
     \begin{tabular}[c]{@{}l@{}}- Construct the components' pieces according\\ to the defined dependencies;\end{tabular} \\
                                    & - Manage the configuration of the container;                         \\ \midrule
   Endpoint &
     \begin{tabular}[c]{@{}l@{}}- Enclose components that are used by external\\ containers to interact with the container;\end{tabular} \\ \midrule
   \multirow{2}{*}{AMQP} &
     - Define how to consume and publish events in the Message Broker; \\
    &
     \begin{tabular}[c]{@{}l@{}}- Delegate the handling of events received to \\ specific Application processes;\end{tabular} \\ \midrule
   \multirow{2}{*}{GraphQl}         & - Define the interface to be consumed by the frontend;               \\
                                    & - Delegate external requests made to specific Application processes; \\ \midrule
   Persistence &
     \begin{tabular}[c]{@{}l@{}}- Enclose components that interface with \\ containers responsible for persisting data;\end{tabular} \\ \midrule
   Postgres                         & - Interact with a database to persist and query data;                \\ \midrule
   \multirow{4}{*}{Application}     & - Represent the application processes;                               \\
    &
     \begin{tabular}[c]{@{}l@{}}- Ensure the propagation of events related to the\\ process in question, requiring this responsibility to AMQP;\end{tabular} \\
    &
     \begin{tabular}[c]{@{}l@{}}- Ensure the execution of the process in question,\\ requiring this responsibility to Domain Services;\end{tabular} \\
                                    & - Enforce user authorization;                                        \\ \midrule
   \multirow{3}{*}{Domain Services} & - Represent business processes;                                      \\
                                    & - Interact with the Domain;                                          \\
    &
     \begin{tabular}[c]{@{}l@{}}- Ensure the persistence of the data in question,\\ requiring this responsibility to the Persistence;\end{tabular} \\ \midrule
   \multirow{2}{*}{Domain}          & - Represent de business rules and concepts;                          \\
                                    & - Manage the system information;                                     \\ \bottomrule
   \end{tabular}
   \caption{Components responsibilities}
   \label{tab:design:architecture:components:logical:backend}
\end{table}

Finally the architecture used in containers related to the Data Flow Scope is presented. It is based on a simplified version of the Onion Architecture since the intrinsic processes of this containers are much simpler.

As an example the logical view of the Device Ownership Backend is presented in Figure~\ref{fig:design:architecture:component:logical:diagram:ownership}.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/logical/device-ownership-backend.latex}
   }
   \caption[Component Level - Device Ownership Backend - Logical View Diagram]{Component Level - Device Ownership Backend - Logical View Diagram}
   \label{fig:design:architecture:component:logical:diagram:ownership}
\end{figure}

This architecture is used on the containers: (i) Device Management Flow Backend, (ii) Data Decoder Flow Backend, (iii) Data Processor Flow Backend, (iv) Device Ownership Backend. The responsibilities of the components inside AMQP are:

\begin{itemize}
   \item Internal: responsible for communicating with the system via internal topic; 
   \item Ingress: responsible for consuming events/messages coming from data, alert or command topics;
   \item Egress: responsible for publishing events/messages to the data or alert topics.
\end{itemize}

The Memory component is responsible for caching unhandled data units and other information relevant for each context. This component is not present in Data Validator Backend and Alert Dispatcher Backend since they don't need to store context information to function.

The Data Gateway, Device Commander and Data Store backend containers have architectures that derive from this one and can be consulted in Appendix ~\ref{AppendixC}.

\subsubsection*{Components Level - Process View}
\label{subsubsec:design:architecture:components:process}

In this section some internal process deemed relevant are presented through sequence diagrams in order to familiarize the reader with the interactions that occur between components inside a container.

The internal processes that will be evaluated are:

\begin{itemize}
   \item Process Data Unit in Device Management Flow Backend;
   \item Deploy Draft Rule Scenarios in Rule Management Backend;
\end{itemize}

This processes have been chosen in order to introduce the reader to specific operations not yet explored in this chapter.

The first process to explore is meant to clarify how a Data Unit sent by a Controller is processed inside the Device Management Flow Backend. As explained in the \nameref{subsubsec:design:domain:bounded_contexts:device} Section, Data Units sent by a Controller are partitioned into various Data Units. The following diagram, Figure~\ref{fig:design:architecture:component:process:diagram:device}, details this process.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/process/device-management-flow-backend.latex}
   }
   \caption[Component Level - Process Data Unit in Device Management Flow Backend - Process View Diagram]{Component Level - Process Data Unit in Device Management Flow Backend - Process View Diagram}
   \label{fig:design:architecture:component:process:diagram:device}
\end{figure}

As presented in the diagram:

\begin{itemize}
   \item As soon as the message dto arrives it is mapped to the \textit{iot-core} data unit model - step \textbf{2} - this model is used inside every Data Flow container. Before publishing the data unit it is mapped to the dto once again - step \textbf{16} and \textbf{23}. This conversion happens with any other event published and consumed in the system;
   \item If the device information is found a \textit{ping} notification for that device is sent - steps \textbf{6} to \textbf{8}, otherwise an \textit{unknown} notification would be sent and the container would store the data unit;
   \item Each sub device of the controller a new data unit with that device measures is published in the system - steps \textbf{20} to \textbf{24};
\end{itemize}

Next, the process of deploying draft rule scenarios is clarified.
Draft scenarios exist since adding, removing or changing a rule scenario in Alert Dispatcher Backend requires the entire data set to be removed. This procedure can lead to alerts not being dispatched. The next diagram, Figure~\ref{fig:design:architecture:component:process:diagram:rule}, tackles this concern. 

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/process/rule-management-backend.latex}
   }
   \caption[Component Level - Deploy Draft Rule Scenarios in Rule Management Backend - Process View Diagram]{Component Level - Deploy Draft Rule Scenarios in Rule Management Backend - Process View Diagram}
   \label{fig:design:architecture:component:process:diagram:rule}
\end{figure}

As seen in the diagram, to mitigate the number of lost alerts, new rule scenarios are published at best every 30 minutes - step \textbf{1} - and only if any change was made - step \textbf{17} and \textbf{18}.  

\subsubsection*{Components Level - Development View}
\label{subsubsec:design:architecture:components:development}

The development view of each container can also be condensate in the same 3 distinct types presented in the Section \nameref{subsubsec:design:architecture:components:logical}.

The next diagrams, Figure~\ref{fig:design:architecture:component:development:diagram:decoder}, Figure~\ref{fig:design:architecture:component:development:diagram:device} and Figure~\ref{fig:design:architecture:component:development:diagram:ownership} describe this view at the components level.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/development/data-decoder-frontend.latex}
   }
   \caption[Component Level - Data Decoder Frontend - Development View Diagram]{Component Level - Data Decoder Frontend - Development View Diagram}
   \label{fig:design:architecture:component:development:diagram:decoder}
\end{figure}

The packages presented correspond to the components described in the logical view (Figure~\ref{fig:design:architecture:component:logical:diagram:decoder}). Since the names given in both views are different, the following list maps the logical view into the implementation view:

\begin{itemize}
   \item \textit{components} package corresponds to the \textit{Presentation} component;
   \item \textit{auth} package corresponds to the \textit{Auth} component;
   \item \textit{core} package corresponds to the \textit{Utils} component;
   \item \textit{dtos} package corresponds to the \textit{DTOS} component;
   \item \textit{mappers} package corresponds to the \textit{Mappers} component;
   \item \textit{model} package corresponds to the \textit{Model} component;
   \item \textit{services} package corresponds to the \textit{Services} component.
\end{itemize}

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/development/device-management-backend.latex}
   }
   \caption[Component Level - Device Management Backend - Development View Diagram]{Component Level - Device Management Backend - Development View Diagram}
   \label{fig:design:architecture:component:development:diagram:device}
\end{figure}

The packages presented correspond to the components described in the logical view (Figure~\ref{fig:design:architecture:component:logical:diagram:device}). The names given in both views differ only on the case used.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/architectural/level3/development/device-ownership-backend.latex}
   }
   \caption[Component Level - Device Ownership Backend - Development View Diagram]{Component Level - Device Ownership Backend - Development View Diagram}
   \label{fig:design:architecture:component:development:diagram:ownership}
\end{figure}

The packages presented correspond to the components described in the logical view (Figure~\ref{fig:design:architecture:component:logical:diagram:ownership}). The names given in both views differ only on the case used.

\subsubsection*{Components Level - Synopsis}
\label{subsubsec:design:architecture:components:synopsis}

This section presented the architecture used in the developed containers, how software is organized and how some internal process are executed inside this containers. In the following section alternatives to what was designed and developed are discussed.  

\section{Architectural Alternatives Discussed}
\label{sec:design:alternatives}

This section tackles important alternatives that were proposed and discussed during the design and development of the solution but were discarded in detriment for the approaches presented in the \nameref{sec:design:architecture}. 

\subsection{Backend Segregation}
\label{subsec:design:alternatives:backend}

There are three main architectural approaches to this topic: Monolithic Backend - \cite{micromono} -, \gls{SOA} - \cite{ibmsoa} - or Microservices - \cite{martinmicro}. The first question regarding what to choose is whether to split or not split the system in multiple units of work: Monolith vs the other two approaches.

If the decision is to split the system then an important question must be asked: how should one split the system? The system architecture depends on the answer given: a \gls{SOA} emphasizes the reuse of the system functionalities, \cite{ibmsoa}, while Micro Services emphasis the decoupling of the various system components - \cite{micromicro} - and can therefore introduce some functionality duplication as opposed to \gls{SOA} - \cite{soavsmicro}.

But to pick one of this architectures the most important question to ask is: Why do i need architecture \textit{X}? To answer this a set of the concerns deemed more important, with regards to this solution requirements, are discussed:

\begin{itemize}
   \item Time To Market: a \gls{MVP} should be available and ready to use as soon as possible;
   \item Extensibility of the solution: it should be easy to extend the solution with new \gls{IoT} Services;
   \item Operation Cost: the solution has to be efficient to lower the infrastructure costs, tied to the system performance;
   \item System performance: the solution has to be capable of processing a high volumes of data efficiently, tied to the system performance;
\end{itemize}

The first concern, Time to Market, weights heavily in favor of the Monolith approach when developing a \gls{MVP}, \cite{atlassianmono}. This approach is simpler to develop, deploy and has less cognitive overhead when compared to the other two approaches.

Regarding the extensibility of the solution, a Monolith is inherently rigid and hard to extend as the business evolves. This problem is inflated by the fact that the business model envisioned relies heavily on the creation of several distinct \gls{IoT} services. On the order hand the \gls{SOA} and Microservices architecture are preferred since they are open for extension - \cite{microsoftmicro}. 

The last two concerns are related to the scalability of the solution. A Monolithic Backend can be scaled up by increasing the resources - RAM, CPU, GPU and Dick Capacity - of the physical server where the solution is deployed, this is commonly referred as Vertical Scaling. A \gls{SOA} or Micro Service Backend Architecture can be scaled up by increasing the number of physical servers where the solution is deployed, this is commonly referred as Horizontal Scaling.
One can also deploy various independent instances of the same solution and each instance would be assign to a set of costumers. This option is crucial and always possible once the business grows and starts to assist various customers.

The following picture, Figure~\ref{fig:design:alternatives:auth:backend:scale}, summarizes how each architect scales, the \gls{SOA} behaves similarly to the microservices architecture presented.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \includegraphics{assets/figures/microservices.png}
   }
   \caption[Monoliths and Microservices]{Monoliths and Microservices by \cite{martinmicro}}
   \label{fig:design:alternatives:auth:backend:scale}
\end{figure}

The final decision was to follow an architecture based on Microservices even tho this decision had several oversights:

\begin{itemize}
   \item Development Team size: microservices are commonly adopted by big companies where each team of developers is responsible for a subset of microservices. This lowers the friction between teams when developing and deploying the solution and is seen as a big reason to move to a microservice architecture. For this solution, a single developer is responsible for everything;
   \item Time to Market: microservices need to interact with each other though the network, this added demand takes time to design and develop when compared to a monolith solution where communication is done via code;
   \item A solution shouldn't start with a microservice architecture: a solution should migrate to microservices when it becomes too complex and hard to maintain, \cite{ibmmicro}. 
\end{itemize}

The decision made was based on the following assumptions and perceptions:

\begin{itemize}
   \item There are well defined boundaries between the various business processes that the project needs to support;
   \item There is a need to scale the solution early on the road due to high volumes of \gls{IoT} data to process and store;
   \item There are a high number of completely independent \gls{IoT} services to develop;
   \item There are different types of costumers with diverse requirements regarding the deployment and development of the solution.
\end{itemize}

\gls{SOA} was discarded since it focus on business functionality reuse instead of functional requirements segregation. With \gls{SOA} each service is responsible only for one non functional requirement such as: auditing, security, logging, data storage, data presentation, business process logic and others. All these services usually communicate via \gls{ESB}. A new functional requirement or business process requires every type of service to be modified. Microservices on the other hand are separated by functional requirements and each service is responsible for storing data, presenting data, logging and everything else deemed necessary. Microservices are more easily extended when/if needed compared with \gls{SOA} since the focus is on loose coupling services and not highly reusable services.

\subsection{Frontend Segregation}
\label{subsec:design:alternatives:frontend}

This section tackles the need for segregating the frontend into various independent frontends - Microfrontends, \cite{microfrontends} - or to develop a single Frontend to answer the identified requirements.

The non-functional requirements discussed in Section~\ref{sec:requirements:non_functional} enhance the need to develop a product that can be fully extensible and yet close for modifications, strictly following the \gls{OCP}. This need arises so that costumer entities can easily create new \gls{IoT} services without the need to alter any close source code that is produced internally.

The Microfrontends Architecture when applied to this project has the same oversights, assumptions and perceptions that inadvertently lead to the decision taken in the \nameref{subsec:design:alternatives:backend} Section. As such the decision was to drop the design and development of a single frontend in favor of a Microfrontends Architecture.

Ultimately this decision, coupled with the Backend Segregation decision made, enforces a business model that follows \gls{OCP} and simplifies the adoption of this solution by third parties.

\subsection{User Authorization/Authentication}
\label{subsec:design:alternatives:auth}

User Authorization and Authentication is an important aspect of the solution. During the requirements elicitation, mentioned in Section~\ref{chap:requirements}, it was clear that several different levels of access had to be given to Tenants, this levels of access also had to be managed by someone. As such, users had to be authenticated in the system and all accesses had to be authorized.

Four approaches were considered:

\begin{itemize}
   \item Internal Authorization Server;
   \item External Authorization Server;
   \item External Authorization Server with Internal Permissions Server;
   \item External Authorization Server with Internal Oauth2 Server;
\end{itemize}

The fourth option was the approach taken.

\subsubsection*{Internal Authorization Server}
\label{subsubsec:design:alternatives:auth:internalauth}

By creating an Internal Authorization Server we could have a normal, private and controlled user authentication/authorization flow in the environment. Both user credentials and permissions would be managed internally.

The following diagram, Figure~\ref{fig:design:alternatives:auth:internalauth:diagram},presents the normal environment flow for this alternative.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/auth/alternative1.latex}
   }
   \caption[User Authorization/Authentication - Internal Authorization Server Alternative - Sequence Diagram]{User Authorization/Authentication - Internal Authorization Server Alternative - Sequence Diagram}
   \label{fig:design:alternatives:auth:internalauth:diagram}
\end{figure}

This alternative introduces the need to internally secure user credentials and other sensitive information from data breaches. It would also require each user to register in sensae with a new account credentials. For this reasons this alternative was discarded.

\subsubsection*{External Authorization Server}
\label{subsubsec:design:alternatives:auth:externalauth}

By using an external Authorization Server there would be no need to store user credentials or permissions. This services are commonly identified as \gls{CIAM} solutions.

The following diagram, Figure~\ref{fig:design:alternatives:auth:externalauth:diagram}, presents the normal environment flow for this alternative.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/auth/alternative2.latex}
   }
   \caption[User Authorization/Authentication - External Authorization Server Alternative - Sequence Diagram]{User Authorization/Authentication - External Authorization Server Alternative - Sequence Diagram}
   \label{fig:design:alternatives:auth:externalauth:diagram}
\end{figure}

This approach would create a strong dependency to the \gls{CIAM} solution used since all user permissions and credentials would have to be managed by the \gls{CIAM} solution.
Some of this services are: (i) \citetitle{auth0id}, (ii) \citetitle{googleid}, (iii) \citetitle{oktaid}, (iv) \citetitle{amazonid} and (v) \citetitle{azureid}.

The platform Auth0 was tested and is capable of registering user roles and permissions according to the requirements.

As stated before, the dependency created would force the environment to always be coupled to the chosen \gls{CIAM} solution. For this reason this alternative was discarded.

\subsubsection*{External Authorization Server with Internal Permissions Server}
\label{subsubsec:design:alternatives:auth:externalauthinternalpermission}

By using an external Authorization Server there would be no need to store user credentials, the user permissions would then be managed internally via a \textit{Permissions Server}.

The following diagram, Figure~\ref{fig:design:alternatives:auth:externalauthinternalpermission:diagram}, presents the normal environment flow for this alternative.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/auth/alternative3.latex}
   }
   \caption[User Authorization/Authentication - External Authorization Server with Internal Permissions Server Alternative - Sequence Diagram]{User Authorization/Authentication - External Authorization Server with Internal Permissions Server Alternative - Sequence Diagram}
   \label{fig:design:alternatives:auth:externalauthinternalpermission:diagram}
\end{figure}

This approach would create a dependency to the \gls{CIAM} solution used and presented in the second alternative.

This dependency is less severe compared with the second alternative since all permissions would be managed internally.
This approach would require any backend to query the \textit{Permissions Server} for user permissions so that it could verify if the user was authorized to preform the requested action or not. This would therefore linger down the performance of the system since each action would have to be verified according to the \textit{Permissions Server} information.

\subsubsection*{External Authorization Server with Internal Oauth2 Server}
\label{subsubsec:design:alternatives:auth:externalauthinternaloauth}

By using an external Authorization Server there would be no need to store user credentials. An internal Oauth2 Server would remove the direct dependency to the \textit{Permissions Server} presented in the third alternative.

This alternative is introduced in Figure~\ref{fig:design:architecture:container:process:diagram:authentication} and Figure~\ref{fig:design:architecture:container:process:diagram:authorization} where the Internal Oauth2 Server is the Identity Management Backend.

This approach would create a dependency to the \gls{CIAM} solution used and presented in the second alternative. This dependency is less severe compared with the second alternative since all user permissions would be managed internally.
This approach would require the system to create and refresh \textit{access tokens} based on the \textit{id token} received by the external \gls{CIAM} solution. Contrary to the third alternative it would not create excessive pressure in a specific container.

This approach also allows the system to easily integrate with more than one \gls{CIAM} solution while managing user permissions in a single place. The \gls{CIAM} solutions that \textbf{Sensae Console} is integrated with are:

\begin{itemize}
   \item Google Identity Platform: for common individuals that want to use the system, since almost everyone has a google account; 
   \item Azure Active Directory: for companies and organizations since most use Office 365 services internally.
\end{itemize}

Due to the reasons presented above, this was the adopted approach.

\subsection{Data Flow Pipeline}
\label{subsec:design:alternatives:flow}

This section debates how the various Data Flow Containers should communicate with each other. 

Synchronous communication, such as HTTP requests, was promptly discarded since there is no need for each Container to acknowledge the outcome of the Data Unit that it sent and this type of communication would linger the performance of the Data Flow Scope by creating chained requests, an anti pattern when using a Microservice Architecture, \cite{microsoftmicroanti}.

According to \cite{microsoftasync}, there are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication. It is common to use both of this types in the same solution depending on the requirements. This type of communication is usually composed by the following participants:

\begin{itemize}
   \item Broker: responsible for establishing a communication channel between Receivers and Publishers;
   \item Publishers: responsible for sending messages;
   \item Receivers: responsible for consuming messages;
\end{itemize}

Looking at the Figure~\ref{fig:design:architecture:container:process:diagram:flow} it appears that a simple \textit{single receiver message-based communication} would be sufficient but this approach isn't as flexible as other options. By following a \textit{multiple receivers message-based communication} additional receivers can be added in the future without the need to modify the sender service. As an example, the Data Store container can be modified to consume any type of Data Unit without changing the containers that produce them.

The final issue to discuss is whether Receivers should pull messages from the Broker (via pulling) or the Broker should push messages to Receivers, this topic is discussed in \citetitle{pubsubpushpull}, mentioned as Push vs Pull. Pushing messages to Receivers can overwhelm a receiver when its rate of consumption falls below the rate of production. The Pull approach offers Receivers the option to consume messages at the rate that they are capable of but can be wasteful in systems where messages are not abundant, \cite{pubsubpushpullrab}. The operations preformed in each Data Flow container are meant to be fast and simply, and as such overwhelming a receiver was not taken into consideration. The Push approach was preferred since it theoretically enables faster reactions to new message compared to the Push approach.

As such, it was decided that the Data Flow Pipeline would work based on the publish/subscribe pattern on top of asynchronous messaging communication. Messages would be published to a broker and then routed to consumers.

\subsection{Internal Communication}
\label{subsec:design:alternatives:internal}

This section tackles how the Data Flow Scope should be kept up to date on the configurations made in the Configuration Scope. Five alternatives have been discussed:

\begin{itemize}
   \item \textbf{First option}: Data Flow Containers directly access the Database related to their Context;
   \item \textbf{Second option}: Data Flow Containers request information to their context's Configuration Scope Container via synchronous calls;
   \item \textbf{Third option}: Data Flow Containers are feed updates to their context configurations via asynchronous calls and store this information;
   \item \textbf{Fourth option}: A shared, in memory, database is kept, Configuration Scope writes to it and Data Flow Scope queries information from it;
   \item \textbf{Fifth option}: An append-only log is used to store configuration logs, the Configuration Scope writes to it and the Data Flow Scope can always read from it.  
\end{itemize}

The third option was the approach taken.

\subsubsection*{First Option}
\label{subsubsec:design:alternatives:internal:first}

This option ensures that the Data Flow Containers are kept updated by giving them direct access to the source of truth, the database. The logical view diagram in Figure~\ref{fig:design:alternatives:internal:first:diagram} describes how this option functions.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/internal/alternative1.latex}
   }
   \caption[Internal Communication - First Option - Logical View Diagram]{Internal Communication - First Option - Logical View Diagram}
   \label{fig:design:alternatives:internal:first:diagram}
\end{figure}

This approach ensures that the Message Broker is only used to transport Data Units, Alerts and Commands, alleviating it from an heavy responsibility.
That responsibility is assigned to the \textit{X Context Flow} Container and the \textit{X Context Database} Container.
This approach has several drawbacks such as:

\begin{itemize}
   \item The \textit{X Context Flow} Container has full access to superfluous configuration details related to that context configuration;
   \item The same database access has to be developed and maintained in two separated containers;
   \item All database accesses are blocking calls by nature that would slow down the process;
   \item Data Flow containers can't reliably cache information collected since there is no way to know when the corresponding information was updated. Meaning that every time a new message arrives the database has to be queried.
\end{itemize}

Due to this drawbacks this option was eventually dropped.

\subsubsection*{Second Option}
\label{subsubsec:design:alternatives:internal:second}

This option ensures that the Data Flow Containers are kept updated querying information from a \gls{REST} \gls{API} provided by the Configuration Containers. The logical view diagram in Figure~\ref{fig:design:alternatives:internal:second:diagram} describes how this option functions.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/internal/alternative2.latex}
   }
   \caption[Internal Communication - Second Option - Logical View Diagram]{Internal Communication - Second Option - Logical View Diagram}
   \label{fig:design:alternatives:internal:second:diagram}
\end{figure}

This approach doesn't suffer from all drawbacks stated for the first option but still requires a blocking call to the \textit{X Context Backend} Container every time a new message arrives to the \textit{X Context Flow} Container.

It's an improvement of the first option but still has some serious drawbacks and therefore it was also abandoned. 

\subsubsection*{Third Option}
\label{subsubsec:design:alternatives:internal:third}

This option ensures that the Data Flow Containers are kept updated by allowing them to subscribe to changes made in their context's configuration. The logical view diagram in Figure~\ref{fig:design:alternatives:internal:third:diagram} describes how this option functions.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/internal/alternative3.latex}
   }
   \caption[Internal Communication - Third Option - Logical View Diagram]{Internal Communication - Third Option - Logical View Diagram}
   \label{fig:design:alternatives:internal:third:diagram}
\end{figure}

The major improvement of this approach when compared with the options above is that, since \textit{X Context Flow} Container subscribes to configuration updates, it can reliably keep a cache with just the needed information (and not the entire context configuration). This works since \textit{X Context Flow} Containers can discard updates related to information that they currently don't use. Once the container needs that information, it can send an event requesting what it needs and that information arrives later as a normal update to the configuration. 
All \textit{X Context Flow} external interactions also rely on asynchronous communication, ensuring a more robust performance.

The main drawback to this option is that the \textit{Message Broker} becomes responsible for yet another communication topic inside the environment.

Despite this drawback this is the option currently in use. The following options purpose alternatives to tackle this drawbacks.

\subsubsection*{Fourth Option}
\label{subsubsec:design:alternatives:internal:fourth}

This option ensures that the Data Flow Containers are kept updated by allowing them to query information from an \textit{Internal State Database}. This approach differs from the first option since the \textit{Internal State Database} is supposed to be a fast in memory database with only the needed information for Data Flow Containers to process Data Units, Alerts and Commands. The logical view diagram in Figure~\ref{fig:design:alternatives:internal:fourth:diagram} describes how this option functions.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/internal/alternative4.latex}
   }
   \caption[Internal Communication - Fourth Option - Logical View Diagram]{Internal Communication - Fourth Option - Logical View Diagram}
   \label{fig:design:alternatives:internal:fourth:diagram}
\end{figure}

This approach would remove the responsibly from the \textit{Message Broker} to maintaining the internal state updated in the Data Flow Scope.
The \textit{Internal State Database} would in turn store information that \textit{X Content Flow} could query.

The main drawbacks of this approach are the same stated in the second option, even tho they can be mitigated by leveraging technologies that tackle distributed caching problems.

\subsubsection*{Fifth Option}
\label{subsubsec:design:alternatives:internal:fifth}

This option ensures that the Data Flow Containers are kept updated by allowing them to subscribe to changes made in their context's configuration. This option diverges from the third option since the event store would persist all updates to contexts configurations. The logical view diagram in Figure~\ref{fig:design:alternatives:internal:fifth:diagram} describes how this option functions.

\begin{figure}[H]
   \centering
   \resizebox{\columnwidth}{!}
   {
      \input{assets/diagrams/design/alternatives/internal/alternative5.latex}
   }
   \caption[Internal Communication - Fifth Option - Logical View Diagram]{Internal Communication - Fifth Option - Logical View Diagram}
   \label{fig:design:alternatives:internal:fifth:diagram}
\end{figure}

The \textit{X Context Flow} Container would use event sourcing to reach the current state of its context configuration on start up and then cache this state internally. New events would then be sent automatically via subscription to keep the state up-to-date.

The main drawback of this approach is that the container can't keep just the needed portion of configurations without recreating the entire state though event sourcing.

\section{Synopsis}
\label{sec:design:synopsis}

This chapter presented to the reader the design of \textbf{Sensae Console}, topics such as the domain, the architectural design and alternatives have been discussed here. To complement the description of the system, the next chapter introduces how, following the design proposed, this solution was implemented.
